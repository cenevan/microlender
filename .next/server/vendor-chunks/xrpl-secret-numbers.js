"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/xrpl-secret-numbers";
exports.ids = ["vendor-chunks/xrpl-secret-numbers"];
exports.modules = {

/***/ "(ssr)/./node_modules/xrpl-secret-numbers/dist/index.js":
/*!********************************************************!*\
  !*** ./node_modules/xrpl-secret-numbers/dist/index.js ***!
  \********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Utils = exports.Account = void 0;\n/* Methods  ==================================================================== */\nvar Utils = __importStar(__webpack_require__(/*! ./utils */ \"(ssr)/./node_modules/xrpl-secret-numbers/dist/utils/index.js\"));\nexports.Utils = Utils;\n/* Types ==================================================================== */\nvar Account_1 = __importDefault(__webpack_require__(/*! ./schema/Account */ \"(ssr)/./node_modules/xrpl-secret-numbers/dist/schema/Account.js\"));\nexports.Account = Account_1.default;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMveHJwbC1zZWNyZXQtbnVtYmVycy9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBLG1DQUFtQyxvQ0FBb0MsZ0JBQWdCO0FBQ3ZGLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsMENBQTBDLDRCQUE0QjtBQUN0RSxDQUFDO0FBQ0Q7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxhQUFhLEdBQUcsZUFBZTtBQUMvQjtBQUNBLHlCQUF5QixtQkFBTyxDQUFDLDZFQUFTO0FBQzFDLGFBQWE7QUFDYjtBQUNBLGdDQUFnQyxtQkFBTyxDQUFDLHlGQUFrQjtBQUMxRCxlQUFlIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbWljcm9sZW5kZXIvLi9ub2RlX21vZHVsZXMveHJwbC1zZWNyZXQtbnVtYmVycy9kaXN0L2luZGV4LmpzPzI0OGUiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfSk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fc2V0TW9kdWxlRGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19zZXRNb2R1bGVEZWZhdWx0KSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCB2KSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIFwiZGVmYXVsdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2IH0pO1xufSkgOiBmdW5jdGlvbihvLCB2KSB7XG4gICAgb1tcImRlZmF1bHRcIl0gPSB2O1xufSk7XG52YXIgX19pbXBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydFN0YXIpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoayAhPT0gXCJkZWZhdWx0XCIgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIF9fY3JlYXRlQmluZGluZyhyZXN1bHQsIG1vZCwgayk7XG4gICAgX19zZXRNb2R1bGVEZWZhdWx0KHJlc3VsdCwgbW9kKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuVXRpbHMgPSBleHBvcnRzLkFjY291bnQgPSB2b2lkIDA7XG4vKiBNZXRob2RzICA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSAqL1xudmFyIFV0aWxzID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCIuL3V0aWxzXCIpKTtcbmV4cG9ydHMuVXRpbHMgPSBVdGlscztcbi8qIFR5cGVzID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09ICovXG52YXIgQWNjb3VudF8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL3NjaGVtYS9BY2NvdW50XCIpKTtcbmV4cG9ydHMuQWNjb3VudCA9IEFjY291bnRfMS5kZWZhdWx0O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/xrpl-secret-numbers/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/xrpl-secret-numbers/dist/schema/Account.js":
/*!*****************************************************************!*\
  !*** ./node_modules/xrpl-secret-numbers/dist/schema/Account.js ***!
  \*****************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nvar assert_1 = __importDefault(__webpack_require__(/*! assert */ \"assert\"));\nvar keypairs = __importStar(__webpack_require__(/*! ripple-keypairs */ \"(ssr)/./node_modules/xrpl-secret-numbers/node_modules/ripple-keypairs/dist/index.js\"));\nvar utils = __importStar(__webpack_require__(/*! ../utils */ \"(ssr)/./node_modules/xrpl-secret-numbers/dist/utils/index.js\"));\n/* Class ==================================================================== */\nvar Account = /** @class */ (function () {\n    function Account(SecretNumbers) {\n        var _this = this;\n        this.account = {\n            familySeed: '',\n            address: '',\n            keypair: {\n                publicKey: '',\n                privateKey: ''\n            }\n        };\n        var asserts = function () {\n            assert_1.default.strictEqual(_this.secret.length, 8);\n            _this.secret.forEach(function (r, i) {\n                assert_1.default.strictEqual(r.length, 6);\n            });\n        };\n        var derive = function () {\n            try {\n                var entropy = utils.secretToEntropy(_this.secret);\n                _this.account.familySeed = keypairs.generateSeed({ entropy: entropy });\n                _this.account.keypair = keypairs.deriveKeypair(_this.account.familySeed);\n                _this.account.address = keypairs.deriveAddress(_this.account.keypair.publicKey);\n            }\n            catch (e) {\n                throw e.message;\n            }\n        };\n        if (typeof SecretNumbers === 'string') {\n            this.secret = utils.parseSecretString(SecretNumbers);\n        }\n        else if (Array.isArray(SecretNumbers)) {\n            this.secret = SecretNumbers;\n        }\n        else if (Buffer.isBuffer(SecretNumbers)) {\n            this.secret = utils.entropyToSecret(SecretNumbers);\n        }\n        else {\n            this.secret = utils.randomSecret();\n        }\n        asserts();\n        derive();\n    }\n    Account.prototype.getSecret = function () {\n        return this.secret;\n    };\n    Account.prototype.getSecretString = function () {\n        return this.secret.join(' ');\n    };\n    Account.prototype.getAddress = function () {\n        return this.account.address;\n    };\n    Account.prototype.getFamilySeed = function () {\n        return this.account.familySeed;\n    };\n    Account.prototype.getKeypair = function () {\n        return this.account.keypair;\n    };\n    Account.prototype.toString = function () {\n        return this.getSecretString();\n    };\n    return Account;\n}());\nexports[\"default\"] = Account;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMveHJwbC1zZWNyZXQtbnVtYmVycy9kaXN0L3NjaGVtYS9BY2NvdW50LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBLG1DQUFtQyxvQ0FBb0MsZ0JBQWdCO0FBQ3ZGLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsMENBQTBDLDRCQUE0QjtBQUN0RSxDQUFDO0FBQ0Q7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCwrQkFBK0IsbUJBQU8sQ0FBQyxzQkFBUTtBQUMvQyw0QkFBNEIsbUJBQU8sQ0FBQyw0R0FBaUI7QUFDckQseUJBQXlCLG1CQUFPLENBQUMsOEVBQVU7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtRUFBbUUsa0JBQWtCO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Qsa0JBQWUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9taWNyb2xlbmRlci8uL25vZGVfbW9kdWxlcy94cnBsLXNlY3JldC1udW1iZXJzL2Rpc3Qvc2NoZW1hL0FjY291bnQuanM/ZjJlZiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9KTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19zZXRNb2R1bGVEZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX3NldE1vZHVsZURlZmF1bHQpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgXCJkZWZhdWx0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHYgfSk7XG59KSA6IGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBvW1wiZGVmYXVsdFwiXSA9IHY7XG59KTtcbnZhciBfX2ltcG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhcikgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChrICE9PSBcImRlZmF1bHRcIiAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgX19jcmVhdGVCaW5kaW5nKHJlc3VsdCwgbW9kLCBrKTtcbiAgICBfX3NldE1vZHVsZURlZmF1bHQocmVzdWx0LCBtb2QpO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGFzc2VydF8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJhc3NlcnRcIikpO1xudmFyIGtleXBhaXJzID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCJyaXBwbGUta2V5cGFpcnNcIikpO1xudmFyIHV0aWxzID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCIuLi91dGlsc1wiKSk7XG4vKiBDbGFzcyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSAqL1xudmFyIEFjY291bnQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQWNjb3VudChTZWNyZXROdW1iZXJzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMuYWNjb3VudCA9IHtcbiAgICAgICAgICAgIGZhbWlseVNlZWQ6ICcnLFxuICAgICAgICAgICAgYWRkcmVzczogJycsXG4gICAgICAgICAgICBrZXlwYWlyOiB7XG4gICAgICAgICAgICAgICAgcHVibGljS2V5OiAnJyxcbiAgICAgICAgICAgICAgICBwcml2YXRlS2V5OiAnJ1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB2YXIgYXNzZXJ0cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGFzc2VydF8xLmRlZmF1bHQuc3RyaWN0RXF1YWwoX3RoaXMuc2VjcmV0Lmxlbmd0aCwgOCk7XG4gICAgICAgICAgICBfdGhpcy5zZWNyZXQuZm9yRWFjaChmdW5jdGlvbiAociwgaSkge1xuICAgICAgICAgICAgICAgIGFzc2VydF8xLmRlZmF1bHQuc3RyaWN0RXF1YWwoci5sZW5ndGgsIDYpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIHZhciBkZXJpdmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHZhciBlbnRyb3B5ID0gdXRpbHMuc2VjcmV0VG9FbnRyb3B5KF90aGlzLnNlY3JldCk7XG4gICAgICAgICAgICAgICAgX3RoaXMuYWNjb3VudC5mYW1pbHlTZWVkID0ga2V5cGFpcnMuZ2VuZXJhdGVTZWVkKHsgZW50cm9weTogZW50cm9weSB9KTtcbiAgICAgICAgICAgICAgICBfdGhpcy5hY2NvdW50LmtleXBhaXIgPSBrZXlwYWlycy5kZXJpdmVLZXlwYWlyKF90aGlzLmFjY291bnQuZmFtaWx5U2VlZCk7XG4gICAgICAgICAgICAgICAgX3RoaXMuYWNjb3VudC5hZGRyZXNzID0ga2V5cGFpcnMuZGVyaXZlQWRkcmVzcyhfdGhpcy5hY2NvdW50LmtleXBhaXIucHVibGljS2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgZS5tZXNzYWdlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBpZiAodHlwZW9mIFNlY3JldE51bWJlcnMgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICB0aGlzLnNlY3JldCA9IHV0aWxzLnBhcnNlU2VjcmV0U3RyaW5nKFNlY3JldE51bWJlcnMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoU2VjcmV0TnVtYmVycykpIHtcbiAgICAgICAgICAgIHRoaXMuc2VjcmV0ID0gU2VjcmV0TnVtYmVycztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChCdWZmZXIuaXNCdWZmZXIoU2VjcmV0TnVtYmVycykpIHtcbiAgICAgICAgICAgIHRoaXMuc2VjcmV0ID0gdXRpbHMuZW50cm9weVRvU2VjcmV0KFNlY3JldE51bWJlcnMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5zZWNyZXQgPSB1dGlscy5yYW5kb21TZWNyZXQoKTtcbiAgICAgICAgfVxuICAgICAgICBhc3NlcnRzKCk7XG4gICAgICAgIGRlcml2ZSgpO1xuICAgIH1cbiAgICBBY2NvdW50LnByb3RvdHlwZS5nZXRTZWNyZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNlY3JldDtcbiAgICB9O1xuICAgIEFjY291bnQucHJvdG90eXBlLmdldFNlY3JldFN0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VjcmV0LmpvaW4oJyAnKTtcbiAgICB9O1xuICAgIEFjY291bnQucHJvdG90eXBlLmdldEFkZHJlc3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFjY291bnQuYWRkcmVzcztcbiAgICB9O1xuICAgIEFjY291bnQucHJvdG90eXBlLmdldEZhbWlseVNlZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFjY291bnQuZmFtaWx5U2VlZDtcbiAgICB9O1xuICAgIEFjY291bnQucHJvdG90eXBlLmdldEtleXBhaXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFjY291bnQua2V5cGFpcjtcbiAgICB9O1xuICAgIEFjY291bnQucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRTZWNyZXRTdHJpbmcoKTtcbiAgICB9O1xuICAgIHJldHVybiBBY2NvdW50O1xufSgpKTtcbmV4cG9ydHMuZGVmYXVsdCA9IEFjY291bnQ7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/xrpl-secret-numbers/dist/schema/Account.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/xrpl-secret-numbers/dist/utils/index.js":
/*!**************************************************************!*\
  !*** ./node_modules/xrpl-secret-numbers/dist/utils/index.js ***!
  \**************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.parseSecretString = exports.checkChecksum = exports.calculateChecksum = exports.secretToEntropy = exports.entropyToSecret = exports.randomSecret = exports.randomEntropy = void 0;\nvar assert_1 = __importDefault(__webpack_require__(/*! assert */ \"assert\"));\nvar brorand_1 = __importDefault(__webpack_require__(/*! brorand */ \"(ssr)/./node_modules/brorand/index.js\"));\nfunction randomEntropy() {\n    return Buffer.from(brorand_1.default(16));\n}\nexports.randomEntropy = randomEntropy;\nfunction calculateChecksum(position, value) {\n    return value * (position * 2 + 1) % 9;\n}\nexports.calculateChecksum = calculateChecksum;\nfunction checkChecksum(position, value, checksum) {\n    if (typeof value === 'string') {\n        assert_1.default.strictEqual(value.length, 6);\n        checksum = parseInt(value.slice(5), 10);\n        value = parseInt(value.slice(0, 5), 10);\n    }\n    return value * (position * 2 + 1) % 9 === checksum;\n}\nexports.checkChecksum = checkChecksum;\nfunction entropyToSecret(entropy) {\n    var length = Array(Math.ceil(entropy.length / 2));\n    var chunks = Array.apply(null, length).map(function (a, b) {\n        return entropy.slice(b * 2, ++b * 2);\n    }).map(function (r, i) {\n        var no = parseInt(r.toString('hex'), 16);\n        var fill = '0'.repeat(5 - String(no).length);\n        return fill + String(no) + String(calculateChecksum(i, no));\n    });\n    assert_1.default.equal(chunks.length, 8);\n    return chunks;\n}\nexports.entropyToSecret = entropyToSecret;\nfunction randomSecret() {\n    return entropyToSecret(randomEntropy());\n}\nexports.randomSecret = randomSecret;\nfunction secretToEntropy(secret) {\n    return Buffer.concat(secret.map(function (r, i) {\n        var no = Number(r.slice(0, 5));\n        var checksum = Number(r.slice(5));\n        try {\n            assert_1.default.strictEqual(r.length, 6);\n        }\n        catch (e) {\n            throw new Error('Invalid secret: number invalid');\n        }\n        try {\n            assert_1.default.strictEqual(checkChecksum(i, no, checksum), true);\n        }\n        catch (e) {\n            throw new Error('Invalid secret part: checksum invalid');\n        }\n        var hex = ('0000' + no.toString(16)).slice(-4);\n        return Buffer.from(hex, 'hex');\n    }));\n}\nexports.secretToEntropy = secretToEntropy;\nfunction parseSecretString(secret) {\n    secret = secret.replace(/[^0-9]/g, '');\n    if (secret.length !== 48) {\n        throw new Error('Invalid secret string (should contain 8 blocks of 6 digits');\n    }\n    return Array.apply(null, Array(8)).map(function (a, i) {\n        return secret.slice(i * 6, (i + 1) * 6);\n    });\n}\nexports.parseSecretString = parseSecretString;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMveHJwbC1zZWNyZXQtbnVtYmVycy9kaXN0L3V0aWxzL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QseUJBQXlCLEdBQUcscUJBQXFCLEdBQUcseUJBQXlCLEdBQUcsdUJBQXVCLEdBQUcsdUJBQXVCLEdBQUcsb0JBQW9CLEdBQUcscUJBQXFCO0FBQ2hMLCtCQUErQixtQkFBTyxDQUFDLHNCQUFRO0FBQy9DLGdDQUFnQyxtQkFBTyxDQUFDLHNEQUFTO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSx5QkFBeUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9taWNyb2xlbmRlci8uL25vZGVfbW9kdWxlcy94cnBsLXNlY3JldC1udW1iZXJzL2Rpc3QvdXRpbHMvaW5kZXguanM/MTI5MiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnBhcnNlU2VjcmV0U3RyaW5nID0gZXhwb3J0cy5jaGVja0NoZWNrc3VtID0gZXhwb3J0cy5jYWxjdWxhdGVDaGVja3N1bSA9IGV4cG9ydHMuc2VjcmV0VG9FbnRyb3B5ID0gZXhwb3J0cy5lbnRyb3B5VG9TZWNyZXQgPSBleHBvcnRzLnJhbmRvbVNlY3JldCA9IGV4cG9ydHMucmFuZG9tRW50cm9weSA9IHZvaWQgMDtcbnZhciBhc3NlcnRfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiYXNzZXJ0XCIpKTtcbnZhciBicm9yYW5kXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImJyb3JhbmRcIikpO1xuZnVuY3Rpb24gcmFuZG9tRW50cm9weSgpIHtcbiAgICByZXR1cm4gQnVmZmVyLmZyb20oYnJvcmFuZF8xLmRlZmF1bHQoMTYpKTtcbn1cbmV4cG9ydHMucmFuZG9tRW50cm9weSA9IHJhbmRvbUVudHJvcHk7XG5mdW5jdGlvbiBjYWxjdWxhdGVDaGVja3N1bShwb3NpdGlvbiwgdmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgKiAocG9zaXRpb24gKiAyICsgMSkgJSA5O1xufVxuZXhwb3J0cy5jYWxjdWxhdGVDaGVja3N1bSA9IGNhbGN1bGF0ZUNoZWNrc3VtO1xuZnVuY3Rpb24gY2hlY2tDaGVja3N1bShwb3NpdGlvbiwgdmFsdWUsIGNoZWNrc3VtKSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgYXNzZXJ0XzEuZGVmYXVsdC5zdHJpY3RFcXVhbCh2YWx1ZS5sZW5ndGgsIDYpO1xuICAgICAgICBjaGVja3N1bSA9IHBhcnNlSW50KHZhbHVlLnNsaWNlKDUpLCAxMCk7XG4gICAgICAgIHZhbHVlID0gcGFyc2VJbnQodmFsdWUuc2xpY2UoMCwgNSksIDEwKTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlICogKHBvc2l0aW9uICogMiArIDEpICUgOSA9PT0gY2hlY2tzdW07XG59XG5leHBvcnRzLmNoZWNrQ2hlY2tzdW0gPSBjaGVja0NoZWNrc3VtO1xuZnVuY3Rpb24gZW50cm9weVRvU2VjcmV0KGVudHJvcHkpIHtcbiAgICB2YXIgbGVuZ3RoID0gQXJyYXkoTWF0aC5jZWlsKGVudHJvcHkubGVuZ3RoIC8gMikpO1xuICAgIHZhciBjaHVua3MgPSBBcnJheS5hcHBseShudWxsLCBsZW5ndGgpLm1hcChmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICByZXR1cm4gZW50cm9weS5zbGljZShiICogMiwgKytiICogMik7XG4gICAgfSkubWFwKGZ1bmN0aW9uIChyLCBpKSB7XG4gICAgICAgIHZhciBubyA9IHBhcnNlSW50KHIudG9TdHJpbmcoJ2hleCcpLCAxNik7XG4gICAgICAgIHZhciBmaWxsID0gJzAnLnJlcGVhdCg1IC0gU3RyaW5nKG5vKS5sZW5ndGgpO1xuICAgICAgICByZXR1cm4gZmlsbCArIFN0cmluZyhubykgKyBTdHJpbmcoY2FsY3VsYXRlQ2hlY2tzdW0oaSwgbm8pKTtcbiAgICB9KTtcbiAgICBhc3NlcnRfMS5kZWZhdWx0LmVxdWFsKGNodW5rcy5sZW5ndGgsIDgpO1xuICAgIHJldHVybiBjaHVua3M7XG59XG5leHBvcnRzLmVudHJvcHlUb1NlY3JldCA9IGVudHJvcHlUb1NlY3JldDtcbmZ1bmN0aW9uIHJhbmRvbVNlY3JldCgpIHtcbiAgICByZXR1cm4gZW50cm9weVRvU2VjcmV0KHJhbmRvbUVudHJvcHkoKSk7XG59XG5leHBvcnRzLnJhbmRvbVNlY3JldCA9IHJhbmRvbVNlY3JldDtcbmZ1bmN0aW9uIHNlY3JldFRvRW50cm9weShzZWNyZXQpIHtcbiAgICByZXR1cm4gQnVmZmVyLmNvbmNhdChzZWNyZXQubWFwKGZ1bmN0aW9uIChyLCBpKSB7XG4gICAgICAgIHZhciBubyA9IE51bWJlcihyLnNsaWNlKDAsIDUpKTtcbiAgICAgICAgdmFyIGNoZWNrc3VtID0gTnVtYmVyKHIuc2xpY2UoNSkpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgYXNzZXJ0XzEuZGVmYXVsdC5zdHJpY3RFcXVhbChyLmxlbmd0aCwgNik7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzZWNyZXQ6IG51bWJlciBpbnZhbGlkJyk7XG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGFzc2VydF8xLmRlZmF1bHQuc3RyaWN0RXF1YWwoY2hlY2tDaGVja3N1bShpLCBubywgY2hlY2tzdW0pLCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHNlY3JldCBwYXJ0OiBjaGVja3N1bSBpbnZhbGlkJyk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGhleCA9ICgnMDAwMCcgKyBuby50b1N0cmluZygxNikpLnNsaWNlKC00KTtcbiAgICAgICAgcmV0dXJuIEJ1ZmZlci5mcm9tKGhleCwgJ2hleCcpO1xuICAgIH0pKTtcbn1cbmV4cG9ydHMuc2VjcmV0VG9FbnRyb3B5ID0gc2VjcmV0VG9FbnRyb3B5O1xuZnVuY3Rpb24gcGFyc2VTZWNyZXRTdHJpbmcoc2VjcmV0KSB7XG4gICAgc2VjcmV0ID0gc2VjcmV0LnJlcGxhY2UoL1teMC05XS9nLCAnJyk7XG4gICAgaWYgKHNlY3JldC5sZW5ndGggIT09IDQ4KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzZWNyZXQgc3RyaW5nIChzaG91bGQgY29udGFpbiA4IGJsb2NrcyBvZiA2IGRpZ2l0cycpO1xuICAgIH1cbiAgICByZXR1cm4gQXJyYXkuYXBwbHkobnVsbCwgQXJyYXkoOCkpLm1hcChmdW5jdGlvbiAoYSwgaSkge1xuICAgICAgICByZXR1cm4gc2VjcmV0LnNsaWNlKGkgKiA2LCAoaSArIDEpICogNik7XG4gICAgfSk7XG59XG5leHBvcnRzLnBhcnNlU2VjcmV0U3RyaW5nID0gcGFyc2VTZWNyZXRTdHJpbmc7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/xrpl-secret-numbers/dist/utils/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/xrpl-secret-numbers/node_modules/ripple-address-codec/dist/index.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/xrpl-secret-numbers/node_modules/ripple-address-codec/dist/index.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.isValidXAddress = exports.decodeXAddress = exports.xAddressToClassicAddress = exports.encodeXAddress = exports.classicAddressToXAddress = exports.isValidClassicAddress = exports.decodeAccountPublic = exports.encodeAccountPublic = exports.decodeNodePublic = exports.encodeNodePublic = exports.decodeAccountID = exports.encodeAccountID = exports.decodeSeed = exports.encodeSeed = exports.codec = void 0;\nconst utils_1 = __webpack_require__(/*! @xrplf/isomorphic/utils */ \"(ssr)/./node_modules/@xrplf/isomorphic/dist/utils/index.js\");\nconst xrp_codec_1 = __webpack_require__(/*! ./xrp-codec */ \"(ssr)/./node_modules/xrpl-secret-numbers/node_modules/ripple-address-codec/dist/xrp-codec.js\");\nObject.defineProperty(exports, \"codec\", ({ enumerable: true, get: function () { return xrp_codec_1.codec; } }));\nObject.defineProperty(exports, \"encodeSeed\", ({ enumerable: true, get: function () { return xrp_codec_1.encodeSeed; } }));\nObject.defineProperty(exports, \"decodeSeed\", ({ enumerable: true, get: function () { return xrp_codec_1.decodeSeed; } }));\nObject.defineProperty(exports, \"encodeAccountID\", ({ enumerable: true, get: function () { return xrp_codec_1.encodeAccountID; } }));\nObject.defineProperty(exports, \"decodeAccountID\", ({ enumerable: true, get: function () { return xrp_codec_1.decodeAccountID; } }));\nObject.defineProperty(exports, \"encodeNodePublic\", ({ enumerable: true, get: function () { return xrp_codec_1.encodeNodePublic; } }));\nObject.defineProperty(exports, \"decodeNodePublic\", ({ enumerable: true, get: function () { return xrp_codec_1.decodeNodePublic; } }));\nObject.defineProperty(exports, \"encodeAccountPublic\", ({ enumerable: true, get: function () { return xrp_codec_1.encodeAccountPublic; } }));\nObject.defineProperty(exports, \"decodeAccountPublic\", ({ enumerable: true, get: function () { return xrp_codec_1.decodeAccountPublic; } }));\nObject.defineProperty(exports, \"isValidClassicAddress\", ({ enumerable: true, get: function () { return xrp_codec_1.isValidClassicAddress; } }));\nconst PREFIX_BYTES = {\n    // 5, 68\n    main: Uint8Array.from([0x05, 0x44]),\n    // 4, 147\n    test: Uint8Array.from([0x04, 0x93]),\n};\nconst MAX_32_BIT_UNSIGNED_INT = 4294967295;\nfunction classicAddressToXAddress(classicAddress, tag, test) {\n    const accountId = (0, xrp_codec_1.decodeAccountID)(classicAddress);\n    return encodeXAddress(accountId, tag, test);\n}\nexports.classicAddressToXAddress = classicAddressToXAddress;\nfunction encodeXAddress(accountId, tag, test) {\n    if (accountId.length !== 20) {\n        // RIPEMD160 is 160 bits = 20 bytes\n        throw new Error('Account ID must be 20 bytes');\n    }\n    if (tag !== false && tag > MAX_32_BIT_UNSIGNED_INT) {\n        throw new Error('Invalid tag');\n    }\n    const theTag = tag || 0;\n    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition -- Passing null is a common js mistake\n    const flag = tag === false || tag == null ? 0 : 1;\n    /* eslint-disable no-bitwise ---\n     * need to use bitwise operations here */\n    const bytes = (0, utils_1.concat)([\n        test ? PREFIX_BYTES.test : PREFIX_BYTES.main,\n        accountId,\n        Uint8Array.from([\n            // 0x00 if no tag, 0x01 if 32-bit tag\n            flag,\n            // first byte\n            theTag & 0xff,\n            // second byte\n            (theTag >> 8) & 0xff,\n            // third byte\n            (theTag >> 16) & 0xff,\n            // fourth byte\n            (theTag >> 24) & 0xff,\n            0,\n            0,\n            0,\n            // four zero bytes (reserved for 64-bit tags)\n            0,\n        ]),\n    ]);\n    /* eslint-enable no-bitwise */\n    return xrp_codec_1.codec.encodeChecked(bytes);\n}\nexports.encodeXAddress = encodeXAddress;\nfunction xAddressToClassicAddress(xAddress) {\n    /* eslint-disable @typescript-eslint/naming-convention --\n     * TODO 'test' should be something like 'isTest', do this later\n     */\n    const { accountId, tag, test } = decodeXAddress(xAddress);\n    /* eslint-enable @typescript-eslint/naming-convention */\n    const classicAddress = (0, xrp_codec_1.encodeAccountID)(accountId);\n    return {\n        classicAddress,\n        tag,\n        test,\n    };\n}\nexports.xAddressToClassicAddress = xAddressToClassicAddress;\nfunction decodeXAddress(xAddress) {\n    const decoded = xrp_codec_1.codec.decodeChecked(xAddress);\n    /* eslint-disable @typescript-eslint/naming-convention --\n     * TODO 'test' should be something like 'isTest', do this later\n     */\n    const test = isUint8ArrayForTestAddress(decoded);\n    /* eslint-enable @typescript-eslint/naming-convention */\n    const accountId = decoded.slice(2, 22);\n    const tag = tagFromUint8Array(decoded);\n    return {\n        accountId,\n        tag,\n        test,\n    };\n}\nexports.decodeXAddress = decodeXAddress;\nfunction isUint8ArrayForTestAddress(buf) {\n    const decodedPrefix = buf.slice(0, 2);\n    if ((0, utils_1.equal)(PREFIX_BYTES.main, decodedPrefix)) {\n        return false;\n    }\n    if ((0, utils_1.equal)(PREFIX_BYTES.test, decodedPrefix)) {\n        return true;\n    }\n    throw new Error('Invalid X-address: bad prefix');\n}\nfunction tagFromUint8Array(buf) {\n    const flag = buf[22];\n    if (flag >= 2) {\n        // No support for 64-bit tags at this time\n        throw new Error('Unsupported X-address');\n    }\n    if (flag === 1) {\n        // Little-endian to big-endian\n        return buf[23] + buf[24] * 0x100 + buf[25] * 0x10000 + buf[26] * 0x1000000;\n    }\n    if (flag !== 0) {\n        throw new Error('flag must be zero to indicate no tag');\n    }\n    if (!(0, utils_1.equal)((0, utils_1.hexToBytes)('0000000000000000'), buf.slice(23, 23 + 8))) {\n        throw new Error('remaining bytes must be zero');\n    }\n    return false;\n}\nfunction isValidXAddress(xAddress) {\n    try {\n        decodeXAddress(xAddress);\n    }\n    catch (_error) {\n        return false;\n    }\n    return true;\n}\nexports.isValidXAddress = isValidXAddress;\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMveHJwbC1zZWNyZXQtbnVtYmVycy9ub2RlX21vZHVsZXMvcmlwcGxlLWFkZHJlc3MtY29kZWMvZGlzdC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCx1QkFBdUIsR0FBRyxzQkFBc0IsR0FBRyxnQ0FBZ0MsR0FBRyxzQkFBc0IsR0FBRyxnQ0FBZ0MsR0FBRyw2QkFBNkIsR0FBRywyQkFBMkIsR0FBRywyQkFBMkIsR0FBRyx3QkFBd0IsR0FBRyx3QkFBd0IsR0FBRyx1QkFBdUIsR0FBRyx1QkFBdUIsR0FBRyxrQkFBa0IsR0FBRyxrQkFBa0IsR0FBRyxhQUFhO0FBQy9ZLGdCQUFnQixtQkFBTyxDQUFDLDJGQUF5QjtBQUNqRCxvQkFBb0IsbUJBQU8sQ0FBQyxpSEFBYTtBQUN6Qyx5Q0FBd0MsRUFBRSxxQ0FBcUMsNkJBQTZCLEVBQUM7QUFDN0csOENBQTZDLEVBQUUscUNBQXFDLGtDQUFrQyxFQUFDO0FBQ3ZILDhDQUE2QyxFQUFFLHFDQUFxQyxrQ0FBa0MsRUFBQztBQUN2SCxtREFBa0QsRUFBRSxxQ0FBcUMsdUNBQXVDLEVBQUM7QUFDakksbURBQWtELEVBQUUscUNBQXFDLHVDQUF1QyxFQUFDO0FBQ2pJLG9EQUFtRCxFQUFFLHFDQUFxQyx3Q0FBd0MsRUFBQztBQUNuSSxvREFBbUQsRUFBRSxxQ0FBcUMsd0NBQXdDLEVBQUM7QUFDbkksdURBQXNELEVBQUUscUNBQXFDLDJDQUEyQyxFQUFDO0FBQ3pJLHVEQUFzRCxFQUFFLHFDQUFxQywyQ0FBMkMsRUFBQztBQUN6SSx5REFBd0QsRUFBRSxxQ0FBcUMsNkNBQTZDLEVBQUM7QUFDN0k7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksdUJBQXVCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbWljcm9sZW5kZXIvLi9ub2RlX21vZHVsZXMveHJwbC1zZWNyZXQtbnVtYmVycy9ub2RlX21vZHVsZXMvcmlwcGxlLWFkZHJlc3MtY29kZWMvZGlzdC9pbmRleC5qcz9jMDczIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5pc1ZhbGlkWEFkZHJlc3MgPSBleHBvcnRzLmRlY29kZVhBZGRyZXNzID0gZXhwb3J0cy54QWRkcmVzc1RvQ2xhc3NpY0FkZHJlc3MgPSBleHBvcnRzLmVuY29kZVhBZGRyZXNzID0gZXhwb3J0cy5jbGFzc2ljQWRkcmVzc1RvWEFkZHJlc3MgPSBleHBvcnRzLmlzVmFsaWRDbGFzc2ljQWRkcmVzcyA9IGV4cG9ydHMuZGVjb2RlQWNjb3VudFB1YmxpYyA9IGV4cG9ydHMuZW5jb2RlQWNjb3VudFB1YmxpYyA9IGV4cG9ydHMuZGVjb2RlTm9kZVB1YmxpYyA9IGV4cG9ydHMuZW5jb2RlTm9kZVB1YmxpYyA9IGV4cG9ydHMuZGVjb2RlQWNjb3VudElEID0gZXhwb3J0cy5lbmNvZGVBY2NvdW50SUQgPSBleHBvcnRzLmRlY29kZVNlZWQgPSBleHBvcnRzLmVuY29kZVNlZWQgPSBleHBvcnRzLmNvZGVjID0gdm9pZCAwO1xuY29uc3QgdXRpbHNfMSA9IHJlcXVpcmUoXCJAeHJwbGYvaXNvbW9ycGhpYy91dGlsc1wiKTtcbmNvbnN0IHhycF9jb2RlY18xID0gcmVxdWlyZShcIi4veHJwLWNvZGVjXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiY29kZWNcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHhycF9jb2RlY18xLmNvZGVjOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZW5jb2RlU2VlZFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4geHJwX2NvZGVjXzEuZW5jb2RlU2VlZDsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImRlY29kZVNlZWRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHhycF9jb2RlY18xLmRlY29kZVNlZWQ7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJlbmNvZGVBY2NvdW50SURcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHhycF9jb2RlY18xLmVuY29kZUFjY291bnRJRDsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImRlY29kZUFjY291bnRJRFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4geHJwX2NvZGVjXzEuZGVjb2RlQWNjb3VudElEOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZW5jb2RlTm9kZVB1YmxpY1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4geHJwX2NvZGVjXzEuZW5jb2RlTm9kZVB1YmxpYzsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImRlY29kZU5vZGVQdWJsaWNcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHhycF9jb2RlY18xLmRlY29kZU5vZGVQdWJsaWM7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJlbmNvZGVBY2NvdW50UHVibGljXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB4cnBfY29kZWNfMS5lbmNvZGVBY2NvdW50UHVibGljOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZGVjb2RlQWNjb3VudFB1YmxpY1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4geHJwX2NvZGVjXzEuZGVjb2RlQWNjb3VudFB1YmxpYzsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImlzVmFsaWRDbGFzc2ljQWRkcmVzc1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4geHJwX2NvZGVjXzEuaXNWYWxpZENsYXNzaWNBZGRyZXNzOyB9IH0pO1xuY29uc3QgUFJFRklYX0JZVEVTID0ge1xuICAgIC8vIDUsIDY4XG4gICAgbWFpbjogVWludDhBcnJheS5mcm9tKFsweDA1LCAweDQ0XSksXG4gICAgLy8gNCwgMTQ3XG4gICAgdGVzdDogVWludDhBcnJheS5mcm9tKFsweDA0LCAweDkzXSksXG59O1xuY29uc3QgTUFYXzMyX0JJVF9VTlNJR05FRF9JTlQgPSA0Mjk0OTY3Mjk1O1xuZnVuY3Rpb24gY2xhc3NpY0FkZHJlc3NUb1hBZGRyZXNzKGNsYXNzaWNBZGRyZXNzLCB0YWcsIHRlc3QpIHtcbiAgICBjb25zdCBhY2NvdW50SWQgPSAoMCwgeHJwX2NvZGVjXzEuZGVjb2RlQWNjb3VudElEKShjbGFzc2ljQWRkcmVzcyk7XG4gICAgcmV0dXJuIGVuY29kZVhBZGRyZXNzKGFjY291bnRJZCwgdGFnLCB0ZXN0KTtcbn1cbmV4cG9ydHMuY2xhc3NpY0FkZHJlc3NUb1hBZGRyZXNzID0gY2xhc3NpY0FkZHJlc3NUb1hBZGRyZXNzO1xuZnVuY3Rpb24gZW5jb2RlWEFkZHJlc3MoYWNjb3VudElkLCB0YWcsIHRlc3QpIHtcbiAgICBpZiAoYWNjb3VudElkLmxlbmd0aCAhPT0gMjApIHtcbiAgICAgICAgLy8gUklQRU1EMTYwIGlzIDE2MCBiaXRzID0gMjAgYnl0ZXNcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdBY2NvdW50IElEIG11c3QgYmUgMjAgYnl0ZXMnKTtcbiAgICB9XG4gICAgaWYgKHRhZyAhPT0gZmFsc2UgJiYgdGFnID4gTUFYXzMyX0JJVF9VTlNJR05FRF9JTlQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHRhZycpO1xuICAgIH1cbiAgICBjb25zdCB0aGVUYWcgPSB0YWcgfHwgMDtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVubmVjZXNzYXJ5LWNvbmRpdGlvbiAtLSBQYXNzaW5nIG51bGwgaXMgYSBjb21tb24ganMgbWlzdGFrZVxuICAgIGNvbnN0IGZsYWcgPSB0YWcgPT09IGZhbHNlIHx8IHRhZyA9PSBudWxsID8gMCA6IDE7XG4gICAgLyogZXNsaW50LWRpc2FibGUgbm8tYml0d2lzZSAtLS1cbiAgICAgKiBuZWVkIHRvIHVzZSBiaXR3aXNlIG9wZXJhdGlvbnMgaGVyZSAqL1xuICAgIGNvbnN0IGJ5dGVzID0gKDAsIHV0aWxzXzEuY29uY2F0KShbXG4gICAgICAgIHRlc3QgPyBQUkVGSVhfQllURVMudGVzdCA6IFBSRUZJWF9CWVRFUy5tYWluLFxuICAgICAgICBhY2NvdW50SWQsXG4gICAgICAgIFVpbnQ4QXJyYXkuZnJvbShbXG4gICAgICAgICAgICAvLyAweDAwIGlmIG5vIHRhZywgMHgwMSBpZiAzMi1iaXQgdGFnXG4gICAgICAgICAgICBmbGFnLFxuICAgICAgICAgICAgLy8gZmlyc3QgYnl0ZVxuICAgICAgICAgICAgdGhlVGFnICYgMHhmZixcbiAgICAgICAgICAgIC8vIHNlY29uZCBieXRlXG4gICAgICAgICAgICAodGhlVGFnID4+IDgpICYgMHhmZixcbiAgICAgICAgICAgIC8vIHRoaXJkIGJ5dGVcbiAgICAgICAgICAgICh0aGVUYWcgPj4gMTYpICYgMHhmZixcbiAgICAgICAgICAgIC8vIGZvdXJ0aCBieXRlXG4gICAgICAgICAgICAodGhlVGFnID4+IDI0KSAmIDB4ZmYsXG4gICAgICAgICAgICAwLFxuICAgICAgICAgICAgMCxcbiAgICAgICAgICAgIDAsXG4gICAgICAgICAgICAvLyBmb3VyIHplcm8gYnl0ZXMgKHJlc2VydmVkIGZvciA2NC1iaXQgdGFncylcbiAgICAgICAgICAgIDAsXG4gICAgICAgIF0pLFxuICAgIF0pO1xuICAgIC8qIGVzbGludC1lbmFibGUgbm8tYml0d2lzZSAqL1xuICAgIHJldHVybiB4cnBfY29kZWNfMS5jb2RlYy5lbmNvZGVDaGVja2VkKGJ5dGVzKTtcbn1cbmV4cG9ydHMuZW5jb2RlWEFkZHJlc3MgPSBlbmNvZGVYQWRkcmVzcztcbmZ1bmN0aW9uIHhBZGRyZXNzVG9DbGFzc2ljQWRkcmVzcyh4QWRkcmVzcykge1xuICAgIC8qIGVzbGludC1kaXNhYmxlIEB0eXBlc2NyaXB0LWVzbGludC9uYW1pbmctY29udmVudGlvbiAtLVxuICAgICAqIFRPRE8gJ3Rlc3QnIHNob3VsZCBiZSBzb21ldGhpbmcgbGlrZSAnaXNUZXN0JywgZG8gdGhpcyBsYXRlclxuICAgICAqL1xuICAgIGNvbnN0IHsgYWNjb3VudElkLCB0YWcsIHRlc3QgfSA9IGRlY29kZVhBZGRyZXNzKHhBZGRyZXNzKTtcbiAgICAvKiBlc2xpbnQtZW5hYmxlIEB0eXBlc2NyaXB0LWVzbGludC9uYW1pbmctY29udmVudGlvbiAqL1xuICAgIGNvbnN0IGNsYXNzaWNBZGRyZXNzID0gKDAsIHhycF9jb2RlY18xLmVuY29kZUFjY291bnRJRCkoYWNjb3VudElkKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBjbGFzc2ljQWRkcmVzcyxcbiAgICAgICAgdGFnLFxuICAgICAgICB0ZXN0LFxuICAgIH07XG59XG5leHBvcnRzLnhBZGRyZXNzVG9DbGFzc2ljQWRkcmVzcyA9IHhBZGRyZXNzVG9DbGFzc2ljQWRkcmVzcztcbmZ1bmN0aW9uIGRlY29kZVhBZGRyZXNzKHhBZGRyZXNzKSB7XG4gICAgY29uc3QgZGVjb2RlZCA9IHhycF9jb2RlY18xLmNvZGVjLmRlY29kZUNoZWNrZWQoeEFkZHJlc3MpO1xuICAgIC8qIGVzbGludC1kaXNhYmxlIEB0eXBlc2NyaXB0LWVzbGludC9uYW1pbmctY29udmVudGlvbiAtLVxuICAgICAqIFRPRE8gJ3Rlc3QnIHNob3VsZCBiZSBzb21ldGhpbmcgbGlrZSAnaXNUZXN0JywgZG8gdGhpcyBsYXRlclxuICAgICAqL1xuICAgIGNvbnN0IHRlc3QgPSBpc1VpbnQ4QXJyYXlGb3JUZXN0QWRkcmVzcyhkZWNvZGVkKTtcbiAgICAvKiBlc2xpbnQtZW5hYmxlIEB0eXBlc2NyaXB0LWVzbGludC9uYW1pbmctY29udmVudGlvbiAqL1xuICAgIGNvbnN0IGFjY291bnRJZCA9IGRlY29kZWQuc2xpY2UoMiwgMjIpO1xuICAgIGNvbnN0IHRhZyA9IHRhZ0Zyb21VaW50OEFycmF5KGRlY29kZWQpO1xuICAgIHJldHVybiB7XG4gICAgICAgIGFjY291bnRJZCxcbiAgICAgICAgdGFnLFxuICAgICAgICB0ZXN0LFxuICAgIH07XG59XG5leHBvcnRzLmRlY29kZVhBZGRyZXNzID0gZGVjb2RlWEFkZHJlc3M7XG5mdW5jdGlvbiBpc1VpbnQ4QXJyYXlGb3JUZXN0QWRkcmVzcyhidWYpIHtcbiAgICBjb25zdCBkZWNvZGVkUHJlZml4ID0gYnVmLnNsaWNlKDAsIDIpO1xuICAgIGlmICgoMCwgdXRpbHNfMS5lcXVhbCkoUFJFRklYX0JZVEVTLm1haW4sIGRlY29kZWRQcmVmaXgpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKCgwLCB1dGlsc18xLmVxdWFsKShQUkVGSVhfQllURVMudGVzdCwgZGVjb2RlZFByZWZpeCkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBYLWFkZHJlc3M6IGJhZCBwcmVmaXgnKTtcbn1cbmZ1bmN0aW9uIHRhZ0Zyb21VaW50OEFycmF5KGJ1Zikge1xuICAgIGNvbnN0IGZsYWcgPSBidWZbMjJdO1xuICAgIGlmIChmbGFnID49IDIpIHtcbiAgICAgICAgLy8gTm8gc3VwcG9ydCBmb3IgNjQtYml0IHRhZ3MgYXQgdGhpcyB0aW1lXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVW5zdXBwb3J0ZWQgWC1hZGRyZXNzJyk7XG4gICAgfVxuICAgIGlmIChmbGFnID09PSAxKSB7XG4gICAgICAgIC8vIExpdHRsZS1lbmRpYW4gdG8gYmlnLWVuZGlhblxuICAgICAgICByZXR1cm4gYnVmWzIzXSArIGJ1ZlsyNF0gKiAweDEwMCArIGJ1ZlsyNV0gKiAweDEwMDAwICsgYnVmWzI2XSAqIDB4MTAwMDAwMDtcbiAgICB9XG4gICAgaWYgKGZsYWcgIT09IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdmbGFnIG11c3QgYmUgemVybyB0byBpbmRpY2F0ZSBubyB0YWcnKTtcbiAgICB9XG4gICAgaWYgKCEoMCwgdXRpbHNfMS5lcXVhbCkoKDAsIHV0aWxzXzEuaGV4VG9CeXRlcykoJzAwMDAwMDAwMDAwMDAwMDAnKSwgYnVmLnNsaWNlKDIzLCAyMyArIDgpKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3JlbWFpbmluZyBieXRlcyBtdXN0IGJlIHplcm8nKTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gaXNWYWxpZFhBZGRyZXNzKHhBZGRyZXNzKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgZGVjb2RlWEFkZHJlc3MoeEFkZHJlc3MpO1xuICAgIH1cbiAgICBjYXRjaCAoX2Vycm9yKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG5leHBvcnRzLmlzVmFsaWRYQWRkcmVzcyA9IGlzVmFsaWRYQWRkcmVzcztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/xrpl-secret-numbers/node_modules/ripple-address-codec/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/xrpl-secret-numbers/node_modules/ripple-address-codec/dist/utils.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/xrpl-secret-numbers/node_modules/ripple-address-codec/dist/utils.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.concatArgs = exports.arrayEqual = void 0;\n/**\n * Check whether two sequences (e.g. Arrays of numbers) are equal.\n *\n * @param arr1 - One of the arrays to compare.\n * @param arr2 - The other array to compare.\n */\nfunction arrayEqual(arr1, arr2) {\n    if (arr1.length !== arr2.length) {\n        return false;\n    }\n    return arr1.every((value, index) => value === arr2[index]);\n}\nexports.arrayEqual = arrayEqual;\n/**\n * Check whether a value is a scalar\n *\n * @param val - The value to check.\n */\nfunction isScalar(val) {\n    return typeof val === 'number';\n}\n/**\n * Concatenate all `arguments` into a single array. Each argument can be either\n * a single element or a sequence, which has a `length` property and supports\n * element retrieval via sequence[ix].\n *\n * > concatArgs(1, [2, 3], Uint8Array.from([4,5]), new Uint8Array([6, 7]));\n * [1,2,3,4,5,6,7]\n *\n * @param args - Concatenate of these args into a single array.\n * @returns Array of concatenated arguments\n */\nfunction concatArgs(...args) {\n    return args.flatMap((arg) => {\n        return isScalar(arg) ? [arg] : Array.from(arg);\n    });\n}\nexports.concatArgs = concatArgs;\n//# sourceMappingURL=utils.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMveHJwbC1zZWNyZXQtbnVtYmVycy9ub2RlX21vZHVsZXMvcmlwcGxlLWFkZHJlc3MtY29kZWMvZGlzdC91dGlscy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxrQkFBa0IsR0FBRyxrQkFBa0I7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0Esa0JBQWtCO0FBQ2xCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbWljcm9sZW5kZXIvLi9ub2RlX21vZHVsZXMveHJwbC1zZWNyZXQtbnVtYmVycy9ub2RlX21vZHVsZXMvcmlwcGxlLWFkZHJlc3MtY29kZWMvZGlzdC91dGlscy5qcz9mMzBjIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5jb25jYXRBcmdzID0gZXhwb3J0cy5hcnJheUVxdWFsID0gdm9pZCAwO1xuLyoqXG4gKiBDaGVjayB3aGV0aGVyIHR3byBzZXF1ZW5jZXMgKGUuZy4gQXJyYXlzIG9mIG51bWJlcnMpIGFyZSBlcXVhbC5cbiAqXG4gKiBAcGFyYW0gYXJyMSAtIE9uZSBvZiB0aGUgYXJyYXlzIHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0gYXJyMiAtIFRoZSBvdGhlciBhcnJheSB0byBjb21wYXJlLlxuICovXG5mdW5jdGlvbiBhcnJheUVxdWFsKGFycjEsIGFycjIpIHtcbiAgICBpZiAoYXJyMS5sZW5ndGggIT09IGFycjIubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIGFycjEuZXZlcnkoKHZhbHVlLCBpbmRleCkgPT4gdmFsdWUgPT09IGFycjJbaW5kZXhdKTtcbn1cbmV4cG9ydHMuYXJyYXlFcXVhbCA9IGFycmF5RXF1YWw7XG4vKipcbiAqIENoZWNrIHdoZXRoZXIgYSB2YWx1ZSBpcyBhIHNjYWxhclxuICpcbiAqIEBwYXJhbSB2YWwgLSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKi9cbmZ1bmN0aW9uIGlzU2NhbGFyKHZhbCkge1xuICAgIHJldHVybiB0eXBlb2YgdmFsID09PSAnbnVtYmVyJztcbn1cbi8qKlxuICogQ29uY2F0ZW5hdGUgYWxsIGBhcmd1bWVudHNgIGludG8gYSBzaW5nbGUgYXJyYXkuIEVhY2ggYXJndW1lbnQgY2FuIGJlIGVpdGhlclxuICogYSBzaW5nbGUgZWxlbWVudCBvciBhIHNlcXVlbmNlLCB3aGljaCBoYXMgYSBgbGVuZ3RoYCBwcm9wZXJ0eSBhbmQgc3VwcG9ydHNcbiAqIGVsZW1lbnQgcmV0cmlldmFsIHZpYSBzZXF1ZW5jZVtpeF0uXG4gKlxuICogPiBjb25jYXRBcmdzKDEsIFsyLCAzXSwgVWludDhBcnJheS5mcm9tKFs0LDVdKSwgbmV3IFVpbnQ4QXJyYXkoWzYsIDddKSk7XG4gKiBbMSwyLDMsNCw1LDYsN11cbiAqXG4gKiBAcGFyYW0gYXJncyAtIENvbmNhdGVuYXRlIG9mIHRoZXNlIGFyZ3MgaW50byBhIHNpbmdsZSBhcnJheS5cbiAqIEByZXR1cm5zIEFycmF5IG9mIGNvbmNhdGVuYXRlZCBhcmd1bWVudHNcbiAqL1xuZnVuY3Rpb24gY29uY2F0QXJncyguLi5hcmdzKSB7XG4gICAgcmV0dXJuIGFyZ3MuZmxhdE1hcCgoYXJnKSA9PiB7XG4gICAgICAgIHJldHVybiBpc1NjYWxhcihhcmcpID8gW2FyZ10gOiBBcnJheS5mcm9tKGFyZyk7XG4gICAgfSk7XG59XG5leHBvcnRzLmNvbmNhdEFyZ3MgPSBjb25jYXRBcmdzO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXRpbHMuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/xrpl-secret-numbers/node_modules/ripple-address-codec/dist/utils.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/xrpl-secret-numbers/node_modules/ripple-address-codec/dist/xrp-codec.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/xrpl-secret-numbers/node_modules/ripple-address-codec/dist/xrp-codec.js ***!
  \**********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/**\n * Codec class\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.isValidClassicAddress = exports.decodeAccountPublic = exports.encodeAccountPublic = exports.encodeNodePublic = exports.decodeNodePublic = exports.decodeAddress = exports.decodeAccountID = exports.encodeAddress = exports.encodeAccountID = exports.decodeSeed = exports.encodeSeed = exports.codec = void 0;\nconst base_1 = __webpack_require__(/*! @scure/base */ \"(ssr)/./node_modules/@scure/base/lib/index.js\");\nconst sha256_1 = __webpack_require__(/*! @xrplf/isomorphic/sha256 */ \"(ssr)/./node_modules/@xrplf/isomorphic/dist/sha256/index.js\");\nconst utils_1 = __webpack_require__(/*! ./utils */ \"(ssr)/./node_modules/xrpl-secret-numbers/node_modules/ripple-address-codec/dist/utils.js\");\nclass Codec {\n    constructor(options) {\n        this._sha256 = options.sha256;\n        this._codec = base_1.base58xrp;\n    }\n    /**\n     * Encoder.\n     *\n     * @param bytes - Uint8Array of data to encode.\n     * @param opts - Options object including the version bytes and the expected length of the data to encode.\n     */\n    encode(bytes, opts) {\n        const versions = opts.versions;\n        return this._encodeVersioned(bytes, versions, opts.expectedLength);\n    }\n    /**\n     * Decoder.\n     *\n     * @param base58string - Base58Check-encoded string to decode.\n     * @param opts - Options object including the version byte(s) and the expected length of the data after decoding.\n     */\n    /* eslint-disable max-lines-per-function --\n     * TODO refactor */\n    decode(base58string, opts) {\n        var _a;\n        const versions = opts.versions;\n        const types = opts.versionTypes;\n        const withoutSum = this.decodeChecked(base58string);\n        if (versions.length > 1 && !opts.expectedLength) {\n            throw new Error('expectedLength is required because there are >= 2 possible versions');\n        }\n        const versionLengthGuess = typeof versions[0] === 'number' ? 1 : versions[0].length;\n        const payloadLength = (_a = opts.expectedLength) !== null && _a !== void 0 ? _a : withoutSum.length - versionLengthGuess;\n        const versionBytes = withoutSum.slice(0, -payloadLength);\n        const payload = withoutSum.slice(-payloadLength);\n        for (let i = 0; i < versions.length; i++) {\n            /* eslint-disable @typescript-eslint/consistent-type-assertions --\n             * TODO refactor */\n            const version = Array.isArray(versions[i])\n                ? versions[i]\n                : [versions[i]];\n            if ((0, utils_1.arrayEqual)(versionBytes, version)) {\n                return {\n                    version,\n                    bytes: payload,\n                    type: types ? types[i] : null,\n                };\n            }\n            /* eslint-enable @typescript-eslint/consistent-type-assertions */\n        }\n        throw new Error('version_invalid: version bytes do not match any of the provided version(s)');\n    }\n    encodeChecked(bytes) {\n        const check = this._sha256(this._sha256(bytes)).slice(0, 4);\n        return this._encodeRaw(Uint8Array.from((0, utils_1.concatArgs)(bytes, check)));\n    }\n    decodeChecked(base58string) {\n        const intArray = this._decodeRaw(base58string);\n        if (intArray.byteLength < 5) {\n            throw new Error('invalid_input_size: decoded data must have length >= 5');\n        }\n        if (!this._verifyCheckSum(intArray)) {\n            throw new Error('checksum_invalid');\n        }\n        return intArray.slice(0, -4);\n    }\n    _encodeVersioned(bytes, versions, expectedLength) {\n        if (!checkByteLength(bytes, expectedLength)) {\n            throw new Error('unexpected_payload_length: bytes.length does not match expectedLength.' +\n                ' Ensure that the bytes are a Uint8Array.');\n        }\n        return this.encodeChecked((0, utils_1.concatArgs)(versions, bytes));\n    }\n    _encodeRaw(bytes) {\n        return this._codec.encode(Uint8Array.from(bytes));\n    }\n    /* eslint-enable max-lines-per-function */\n    _decodeRaw(base58string) {\n        return this._codec.decode(base58string);\n    }\n    _verifyCheckSum(bytes) {\n        const computed = this._sha256(this._sha256(bytes.slice(0, -4))).slice(0, 4);\n        const checksum = bytes.slice(-4);\n        return (0, utils_1.arrayEqual)(computed, checksum);\n    }\n}\n/**\n * XRP codec\n */\n// base58 encodings: https://xrpl.org/base58-encodings.html\n// Account address (20 bytes)\nconst ACCOUNT_ID = 0;\n// Account public key (33 bytes)\nconst ACCOUNT_PUBLIC_KEY = 0x23;\n// 33; Seed value (for secret keys) (16 bytes)\nconst FAMILY_SEED = 0x21;\n// 28; Validation public key (33 bytes)\nconst NODE_PUBLIC = 0x1c;\n// [1, 225, 75]\nconst ED25519_SEED = [0x01, 0xe1, 0x4b];\nconst codecOptions = {\n    sha256: sha256_1.sha256,\n};\nconst codecWithXrpAlphabet = new Codec(codecOptions);\nexports.codec = codecWithXrpAlphabet;\n// entropy is a Uint8Array of size 16\n// type is 'ed25519' or 'secp256k1'\nfunction encodeSeed(entropy, type) {\n    if (!checkByteLength(entropy, 16)) {\n        throw new Error('entropy must have length 16');\n    }\n    const opts = {\n        expectedLength: 16,\n        // for secp256k1, use `FAMILY_SEED`\n        versions: type === 'ed25519' ? ED25519_SEED : [FAMILY_SEED],\n    };\n    // prefixes entropy with version bytes\n    return codecWithXrpAlphabet.encode(entropy, opts);\n}\nexports.encodeSeed = encodeSeed;\nfunction decodeSeed(seed, opts = {\n    versionTypes: ['ed25519', 'secp256k1'],\n    versions: [ED25519_SEED, FAMILY_SEED],\n    expectedLength: 16,\n}) {\n    return codecWithXrpAlphabet.decode(seed, opts);\n}\nexports.decodeSeed = decodeSeed;\nfunction encodeAccountID(bytes) {\n    const opts = { versions: [ACCOUNT_ID], expectedLength: 20 };\n    return codecWithXrpAlphabet.encode(bytes, opts);\n}\nexports.encodeAccountID = encodeAccountID;\n/* eslint-disable import/no-unused-modules ---\n * unclear why this is aliased but we should keep it in case someone else is\n * importing it with the aliased name */\nexports.encodeAddress = encodeAccountID;\n/* eslint-enable import/no-unused-modules */\nfunction decodeAccountID(accountId) {\n    const opts = { versions: [ACCOUNT_ID], expectedLength: 20 };\n    return codecWithXrpAlphabet.decode(accountId, opts).bytes;\n}\nexports.decodeAccountID = decodeAccountID;\n/* eslint-disable import/no-unused-modules ---\n * unclear why this is aliased but we should keep it in case someone else is\n * importing it with the aliased name */\nexports.decodeAddress = decodeAccountID;\n/* eslint-enable import/no-unused-modules */\nfunction decodeNodePublic(base58string) {\n    const opts = { versions: [NODE_PUBLIC], expectedLength: 33 };\n    return codecWithXrpAlphabet.decode(base58string, opts).bytes;\n}\nexports.decodeNodePublic = decodeNodePublic;\nfunction encodeNodePublic(bytes) {\n    const opts = { versions: [NODE_PUBLIC], expectedLength: 33 };\n    return codecWithXrpAlphabet.encode(bytes, opts);\n}\nexports.encodeNodePublic = encodeNodePublic;\nfunction encodeAccountPublic(bytes) {\n    const opts = { versions: [ACCOUNT_PUBLIC_KEY], expectedLength: 33 };\n    return codecWithXrpAlphabet.encode(bytes, opts);\n}\nexports.encodeAccountPublic = encodeAccountPublic;\nfunction decodeAccountPublic(base58string) {\n    const opts = { versions: [ACCOUNT_PUBLIC_KEY], expectedLength: 33 };\n    return codecWithXrpAlphabet.decode(base58string, opts).bytes;\n}\nexports.decodeAccountPublic = decodeAccountPublic;\nfunction isValidClassicAddress(address) {\n    try {\n        decodeAccountID(address);\n    }\n    catch (_error) {\n        return false;\n    }\n    return true;\n}\nexports.isValidClassicAddress = isValidClassicAddress;\nfunction checkByteLength(bytes, expectedLength) {\n    return 'byteLength' in bytes\n        ? bytes.byteLength === expectedLength\n        : bytes.length === expectedLength;\n}\n//# sourceMappingURL=xrp-codec.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMveHJwbC1zZWNyZXQtbnVtYmVycy9ub2RlX21vZHVsZXMvcmlwcGxlLWFkZHJlc3MtY29kZWMvZGlzdC94cnAtY29kZWMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsNkJBQTZCLEdBQUcsMkJBQTJCLEdBQUcsMkJBQTJCLEdBQUcsd0JBQXdCLEdBQUcsd0JBQXdCLEdBQUcscUJBQXFCLEdBQUcsdUJBQXVCLEdBQUcscUJBQXFCLEdBQUcsdUJBQXVCLEdBQUcsa0JBQWtCLEdBQUcsa0JBQWtCLEdBQUcsYUFBYTtBQUM3UyxlQUFlLG1CQUFPLENBQUMsa0VBQWE7QUFDcEMsaUJBQWlCLG1CQUFPLENBQUMsNkZBQTBCO0FBQ25ELGdCQUFnQixtQkFBTyxDQUFDLHlHQUFTO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IscUJBQXFCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbWljcm9sZW5kZXIvLi9ub2RlX21vZHVsZXMveHJwbC1zZWNyZXQtbnVtYmVycy9ub2RlX21vZHVsZXMvcmlwcGxlLWFkZHJlc3MtY29kZWMvZGlzdC94cnAtY29kZWMuanM/OWNiNCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQ29kZWMgY2xhc3NcbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5pc1ZhbGlkQ2xhc3NpY0FkZHJlc3MgPSBleHBvcnRzLmRlY29kZUFjY291bnRQdWJsaWMgPSBleHBvcnRzLmVuY29kZUFjY291bnRQdWJsaWMgPSBleHBvcnRzLmVuY29kZU5vZGVQdWJsaWMgPSBleHBvcnRzLmRlY29kZU5vZGVQdWJsaWMgPSBleHBvcnRzLmRlY29kZUFkZHJlc3MgPSBleHBvcnRzLmRlY29kZUFjY291bnRJRCA9IGV4cG9ydHMuZW5jb2RlQWRkcmVzcyA9IGV4cG9ydHMuZW5jb2RlQWNjb3VudElEID0gZXhwb3J0cy5kZWNvZGVTZWVkID0gZXhwb3J0cy5lbmNvZGVTZWVkID0gZXhwb3J0cy5jb2RlYyA9IHZvaWQgMDtcbmNvbnN0IGJhc2VfMSA9IHJlcXVpcmUoXCJAc2N1cmUvYmFzZVwiKTtcbmNvbnN0IHNoYTI1Nl8xID0gcmVxdWlyZShcIkB4cnBsZi9pc29tb3JwaGljL3NoYTI1NlwiKTtcbmNvbnN0IHV0aWxzXzEgPSByZXF1aXJlKFwiLi91dGlsc1wiKTtcbmNsYXNzIENvZGVjIHtcbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgICAgIHRoaXMuX3NoYTI1NiA9IG9wdGlvbnMuc2hhMjU2O1xuICAgICAgICB0aGlzLl9jb2RlYyA9IGJhc2VfMS5iYXNlNTh4cnA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVuY29kZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gYnl0ZXMgLSBVaW50OEFycmF5IG9mIGRhdGEgdG8gZW5jb2RlLlxuICAgICAqIEBwYXJhbSBvcHRzIC0gT3B0aW9ucyBvYmplY3QgaW5jbHVkaW5nIHRoZSB2ZXJzaW9uIGJ5dGVzIGFuZCB0aGUgZXhwZWN0ZWQgbGVuZ3RoIG9mIHRoZSBkYXRhIHRvIGVuY29kZS5cbiAgICAgKi9cbiAgICBlbmNvZGUoYnl0ZXMsIG9wdHMpIHtcbiAgICAgICAgY29uc3QgdmVyc2lvbnMgPSBvcHRzLnZlcnNpb25zO1xuICAgICAgICByZXR1cm4gdGhpcy5fZW5jb2RlVmVyc2lvbmVkKGJ5dGVzLCB2ZXJzaW9ucywgb3B0cy5leHBlY3RlZExlbmd0aCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlY29kZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gYmFzZTU4c3RyaW5nIC0gQmFzZTU4Q2hlY2stZW5jb2RlZCBzdHJpbmcgdG8gZGVjb2RlLlxuICAgICAqIEBwYXJhbSBvcHRzIC0gT3B0aW9ucyBvYmplY3QgaW5jbHVkaW5nIHRoZSB2ZXJzaW9uIGJ5dGUocykgYW5kIHRoZSBleHBlY3RlZCBsZW5ndGggb2YgdGhlIGRhdGEgYWZ0ZXIgZGVjb2RpbmcuXG4gICAgICovXG4gICAgLyogZXNsaW50LWRpc2FibGUgbWF4LWxpbmVzLXBlci1mdW5jdGlvbiAtLVxuICAgICAqIFRPRE8gcmVmYWN0b3IgKi9cbiAgICBkZWNvZGUoYmFzZTU4c3RyaW5nLCBvcHRzKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgY29uc3QgdmVyc2lvbnMgPSBvcHRzLnZlcnNpb25zO1xuICAgICAgICBjb25zdCB0eXBlcyA9IG9wdHMudmVyc2lvblR5cGVzO1xuICAgICAgICBjb25zdCB3aXRob3V0U3VtID0gdGhpcy5kZWNvZGVDaGVja2VkKGJhc2U1OHN0cmluZyk7XG4gICAgICAgIGlmICh2ZXJzaW9ucy5sZW5ndGggPiAxICYmICFvcHRzLmV4cGVjdGVkTGVuZ3RoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2V4cGVjdGVkTGVuZ3RoIGlzIHJlcXVpcmVkIGJlY2F1c2UgdGhlcmUgYXJlID49IDIgcG9zc2libGUgdmVyc2lvbnMnKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB2ZXJzaW9uTGVuZ3RoR3Vlc3MgPSB0eXBlb2YgdmVyc2lvbnNbMF0gPT09ICdudW1iZXInID8gMSA6IHZlcnNpb25zWzBdLmxlbmd0aDtcbiAgICAgICAgY29uc3QgcGF5bG9hZExlbmd0aCA9IChfYSA9IG9wdHMuZXhwZWN0ZWRMZW5ndGgpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHdpdGhvdXRTdW0ubGVuZ3RoIC0gdmVyc2lvbkxlbmd0aEd1ZXNzO1xuICAgICAgICBjb25zdCB2ZXJzaW9uQnl0ZXMgPSB3aXRob3V0U3VtLnNsaWNlKDAsIC1wYXlsb2FkTGVuZ3RoKTtcbiAgICAgICAgY29uc3QgcGF5bG9hZCA9IHdpdGhvdXRTdW0uc2xpY2UoLXBheWxvYWRMZW5ndGgpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZlcnNpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAvKiBlc2xpbnQtZGlzYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvY29uc2lzdGVudC10eXBlLWFzc2VydGlvbnMgLS1cbiAgICAgICAgICAgICAqIFRPRE8gcmVmYWN0b3IgKi9cbiAgICAgICAgICAgIGNvbnN0IHZlcnNpb24gPSBBcnJheS5pc0FycmF5KHZlcnNpb25zW2ldKVxuICAgICAgICAgICAgICAgID8gdmVyc2lvbnNbaV1cbiAgICAgICAgICAgICAgICA6IFt2ZXJzaW9uc1tpXV07XG4gICAgICAgICAgICBpZiAoKDAsIHV0aWxzXzEuYXJyYXlFcXVhbCkodmVyc2lvbkJ5dGVzLCB2ZXJzaW9uKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHZlcnNpb24sXG4gICAgICAgICAgICAgICAgICAgIGJ5dGVzOiBwYXlsb2FkLFxuICAgICAgICAgICAgICAgICAgICB0eXBlOiB0eXBlcyA/IHR5cGVzW2ldIDogbnVsbCxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLyogZXNsaW50LWVuYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvY29uc2lzdGVudC10eXBlLWFzc2VydGlvbnMgKi9cbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3ZlcnNpb25faW52YWxpZDogdmVyc2lvbiBieXRlcyBkbyBub3QgbWF0Y2ggYW55IG9mIHRoZSBwcm92aWRlZCB2ZXJzaW9uKHMpJyk7XG4gICAgfVxuICAgIGVuY29kZUNoZWNrZWQoYnl0ZXMpIHtcbiAgICAgICAgY29uc3QgY2hlY2sgPSB0aGlzLl9zaGEyNTYodGhpcy5fc2hhMjU2KGJ5dGVzKSkuc2xpY2UoMCwgNCk7XG4gICAgICAgIHJldHVybiB0aGlzLl9lbmNvZGVSYXcoVWludDhBcnJheS5mcm9tKCgwLCB1dGlsc18xLmNvbmNhdEFyZ3MpKGJ5dGVzLCBjaGVjaykpKTtcbiAgICB9XG4gICAgZGVjb2RlQ2hlY2tlZChiYXNlNThzdHJpbmcpIHtcbiAgICAgICAgY29uc3QgaW50QXJyYXkgPSB0aGlzLl9kZWNvZGVSYXcoYmFzZTU4c3RyaW5nKTtcbiAgICAgICAgaWYgKGludEFycmF5LmJ5dGVMZW5ndGggPCA1KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWRfaW5wdXRfc2l6ZTogZGVjb2RlZCBkYXRhIG11c3QgaGF2ZSBsZW5ndGggPj0gNScpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5fdmVyaWZ5Q2hlY2tTdW0oaW50QXJyYXkpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NoZWNrc3VtX2ludmFsaWQnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaW50QXJyYXkuc2xpY2UoMCwgLTQpO1xuICAgIH1cbiAgICBfZW5jb2RlVmVyc2lvbmVkKGJ5dGVzLCB2ZXJzaW9ucywgZXhwZWN0ZWRMZW5ndGgpIHtcbiAgICAgICAgaWYgKCFjaGVja0J5dGVMZW5ndGgoYnl0ZXMsIGV4cGVjdGVkTGVuZ3RoKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd1bmV4cGVjdGVkX3BheWxvYWRfbGVuZ3RoOiBieXRlcy5sZW5ndGggZG9lcyBub3QgbWF0Y2ggZXhwZWN0ZWRMZW5ndGguJyArXG4gICAgICAgICAgICAgICAgJyBFbnN1cmUgdGhhdCB0aGUgYnl0ZXMgYXJlIGEgVWludDhBcnJheS4nKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5lbmNvZGVDaGVja2VkKCgwLCB1dGlsc18xLmNvbmNhdEFyZ3MpKHZlcnNpb25zLCBieXRlcykpO1xuICAgIH1cbiAgICBfZW5jb2RlUmF3KGJ5dGVzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jb2RlYy5lbmNvZGUoVWludDhBcnJheS5mcm9tKGJ5dGVzKSk7XG4gICAgfVxuICAgIC8qIGVzbGludC1lbmFibGUgbWF4LWxpbmVzLXBlci1mdW5jdGlvbiAqL1xuICAgIF9kZWNvZGVSYXcoYmFzZTU4c3RyaW5nKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jb2RlYy5kZWNvZGUoYmFzZTU4c3RyaW5nKTtcbiAgICB9XG4gICAgX3ZlcmlmeUNoZWNrU3VtKGJ5dGVzKSB7XG4gICAgICAgIGNvbnN0IGNvbXB1dGVkID0gdGhpcy5fc2hhMjU2KHRoaXMuX3NoYTI1NihieXRlcy5zbGljZSgwLCAtNCkpKS5zbGljZSgwLCA0KTtcbiAgICAgICAgY29uc3QgY2hlY2tzdW0gPSBieXRlcy5zbGljZSgtNCk7XG4gICAgICAgIHJldHVybiAoMCwgdXRpbHNfMS5hcnJheUVxdWFsKShjb21wdXRlZCwgY2hlY2tzdW0pO1xuICAgIH1cbn1cbi8qKlxuICogWFJQIGNvZGVjXG4gKi9cbi8vIGJhc2U1OCBlbmNvZGluZ3M6IGh0dHBzOi8veHJwbC5vcmcvYmFzZTU4LWVuY29kaW5ncy5odG1sXG4vLyBBY2NvdW50IGFkZHJlc3MgKDIwIGJ5dGVzKVxuY29uc3QgQUNDT1VOVF9JRCA9IDA7XG4vLyBBY2NvdW50IHB1YmxpYyBrZXkgKDMzIGJ5dGVzKVxuY29uc3QgQUNDT1VOVF9QVUJMSUNfS0VZID0gMHgyMztcbi8vIDMzOyBTZWVkIHZhbHVlIChmb3Igc2VjcmV0IGtleXMpICgxNiBieXRlcylcbmNvbnN0IEZBTUlMWV9TRUVEID0gMHgyMTtcbi8vIDI4OyBWYWxpZGF0aW9uIHB1YmxpYyBrZXkgKDMzIGJ5dGVzKVxuY29uc3QgTk9ERV9QVUJMSUMgPSAweDFjO1xuLy8gWzEsIDIyNSwgNzVdXG5jb25zdCBFRDI1NTE5X1NFRUQgPSBbMHgwMSwgMHhlMSwgMHg0Yl07XG5jb25zdCBjb2RlY09wdGlvbnMgPSB7XG4gICAgc2hhMjU2OiBzaGEyNTZfMS5zaGEyNTYsXG59O1xuY29uc3QgY29kZWNXaXRoWHJwQWxwaGFiZXQgPSBuZXcgQ29kZWMoY29kZWNPcHRpb25zKTtcbmV4cG9ydHMuY29kZWMgPSBjb2RlY1dpdGhYcnBBbHBoYWJldDtcbi8vIGVudHJvcHkgaXMgYSBVaW50OEFycmF5IG9mIHNpemUgMTZcbi8vIHR5cGUgaXMgJ2VkMjU1MTknIG9yICdzZWNwMjU2azEnXG5mdW5jdGlvbiBlbmNvZGVTZWVkKGVudHJvcHksIHR5cGUpIHtcbiAgICBpZiAoIWNoZWNrQnl0ZUxlbmd0aChlbnRyb3B5LCAxNikpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdlbnRyb3B5IG11c3QgaGF2ZSBsZW5ndGggMTYnKTtcbiAgICB9XG4gICAgY29uc3Qgb3B0cyA9IHtcbiAgICAgICAgZXhwZWN0ZWRMZW5ndGg6IDE2LFxuICAgICAgICAvLyBmb3Igc2VjcDI1NmsxLCB1c2UgYEZBTUlMWV9TRUVEYFxuICAgICAgICB2ZXJzaW9uczogdHlwZSA9PT0gJ2VkMjU1MTknID8gRUQyNTUxOV9TRUVEIDogW0ZBTUlMWV9TRUVEXSxcbiAgICB9O1xuICAgIC8vIHByZWZpeGVzIGVudHJvcHkgd2l0aCB2ZXJzaW9uIGJ5dGVzXG4gICAgcmV0dXJuIGNvZGVjV2l0aFhycEFscGhhYmV0LmVuY29kZShlbnRyb3B5LCBvcHRzKTtcbn1cbmV4cG9ydHMuZW5jb2RlU2VlZCA9IGVuY29kZVNlZWQ7XG5mdW5jdGlvbiBkZWNvZGVTZWVkKHNlZWQsIG9wdHMgPSB7XG4gICAgdmVyc2lvblR5cGVzOiBbJ2VkMjU1MTknLCAnc2VjcDI1NmsxJ10sXG4gICAgdmVyc2lvbnM6IFtFRDI1NTE5X1NFRUQsIEZBTUlMWV9TRUVEXSxcbiAgICBleHBlY3RlZExlbmd0aDogMTYsXG59KSB7XG4gICAgcmV0dXJuIGNvZGVjV2l0aFhycEFscGhhYmV0LmRlY29kZShzZWVkLCBvcHRzKTtcbn1cbmV4cG9ydHMuZGVjb2RlU2VlZCA9IGRlY29kZVNlZWQ7XG5mdW5jdGlvbiBlbmNvZGVBY2NvdW50SUQoYnl0ZXMpIHtcbiAgICBjb25zdCBvcHRzID0geyB2ZXJzaW9uczogW0FDQ09VTlRfSURdLCBleHBlY3RlZExlbmd0aDogMjAgfTtcbiAgICByZXR1cm4gY29kZWNXaXRoWHJwQWxwaGFiZXQuZW5jb2RlKGJ5dGVzLCBvcHRzKTtcbn1cbmV4cG9ydHMuZW5jb2RlQWNjb3VudElEID0gZW5jb2RlQWNjb3VudElEO1xuLyogZXNsaW50LWRpc2FibGUgaW1wb3J0L25vLXVudXNlZC1tb2R1bGVzIC0tLVxuICogdW5jbGVhciB3aHkgdGhpcyBpcyBhbGlhc2VkIGJ1dCB3ZSBzaG91bGQga2VlcCBpdCBpbiBjYXNlIHNvbWVvbmUgZWxzZSBpc1xuICogaW1wb3J0aW5nIGl0IHdpdGggdGhlIGFsaWFzZWQgbmFtZSAqL1xuZXhwb3J0cy5lbmNvZGVBZGRyZXNzID0gZW5jb2RlQWNjb3VudElEO1xuLyogZXNsaW50LWVuYWJsZSBpbXBvcnQvbm8tdW51c2VkLW1vZHVsZXMgKi9cbmZ1bmN0aW9uIGRlY29kZUFjY291bnRJRChhY2NvdW50SWQpIHtcbiAgICBjb25zdCBvcHRzID0geyB2ZXJzaW9uczogW0FDQ09VTlRfSURdLCBleHBlY3RlZExlbmd0aDogMjAgfTtcbiAgICByZXR1cm4gY29kZWNXaXRoWHJwQWxwaGFiZXQuZGVjb2RlKGFjY291bnRJZCwgb3B0cykuYnl0ZXM7XG59XG5leHBvcnRzLmRlY29kZUFjY291bnRJRCA9IGRlY29kZUFjY291bnRJRDtcbi8qIGVzbGludC1kaXNhYmxlIGltcG9ydC9uby11bnVzZWQtbW9kdWxlcyAtLS1cbiAqIHVuY2xlYXIgd2h5IHRoaXMgaXMgYWxpYXNlZCBidXQgd2Ugc2hvdWxkIGtlZXAgaXQgaW4gY2FzZSBzb21lb25lIGVsc2UgaXNcbiAqIGltcG9ydGluZyBpdCB3aXRoIHRoZSBhbGlhc2VkIG5hbWUgKi9cbmV4cG9ydHMuZGVjb2RlQWRkcmVzcyA9IGRlY29kZUFjY291bnRJRDtcbi8qIGVzbGludC1lbmFibGUgaW1wb3J0L25vLXVudXNlZC1tb2R1bGVzICovXG5mdW5jdGlvbiBkZWNvZGVOb2RlUHVibGljKGJhc2U1OHN0cmluZykge1xuICAgIGNvbnN0IG9wdHMgPSB7IHZlcnNpb25zOiBbTk9ERV9QVUJMSUNdLCBleHBlY3RlZExlbmd0aDogMzMgfTtcbiAgICByZXR1cm4gY29kZWNXaXRoWHJwQWxwaGFiZXQuZGVjb2RlKGJhc2U1OHN0cmluZywgb3B0cykuYnl0ZXM7XG59XG5leHBvcnRzLmRlY29kZU5vZGVQdWJsaWMgPSBkZWNvZGVOb2RlUHVibGljO1xuZnVuY3Rpb24gZW5jb2RlTm9kZVB1YmxpYyhieXRlcykge1xuICAgIGNvbnN0IG9wdHMgPSB7IHZlcnNpb25zOiBbTk9ERV9QVUJMSUNdLCBleHBlY3RlZExlbmd0aDogMzMgfTtcbiAgICByZXR1cm4gY29kZWNXaXRoWHJwQWxwaGFiZXQuZW5jb2RlKGJ5dGVzLCBvcHRzKTtcbn1cbmV4cG9ydHMuZW5jb2RlTm9kZVB1YmxpYyA9IGVuY29kZU5vZGVQdWJsaWM7XG5mdW5jdGlvbiBlbmNvZGVBY2NvdW50UHVibGljKGJ5dGVzKSB7XG4gICAgY29uc3Qgb3B0cyA9IHsgdmVyc2lvbnM6IFtBQ0NPVU5UX1BVQkxJQ19LRVldLCBleHBlY3RlZExlbmd0aDogMzMgfTtcbiAgICByZXR1cm4gY29kZWNXaXRoWHJwQWxwaGFiZXQuZW5jb2RlKGJ5dGVzLCBvcHRzKTtcbn1cbmV4cG9ydHMuZW5jb2RlQWNjb3VudFB1YmxpYyA9IGVuY29kZUFjY291bnRQdWJsaWM7XG5mdW5jdGlvbiBkZWNvZGVBY2NvdW50UHVibGljKGJhc2U1OHN0cmluZykge1xuICAgIGNvbnN0IG9wdHMgPSB7IHZlcnNpb25zOiBbQUNDT1VOVF9QVUJMSUNfS0VZXSwgZXhwZWN0ZWRMZW5ndGg6IDMzIH07XG4gICAgcmV0dXJuIGNvZGVjV2l0aFhycEFscGhhYmV0LmRlY29kZShiYXNlNThzdHJpbmcsIG9wdHMpLmJ5dGVzO1xufVxuZXhwb3J0cy5kZWNvZGVBY2NvdW50UHVibGljID0gZGVjb2RlQWNjb3VudFB1YmxpYztcbmZ1bmN0aW9uIGlzVmFsaWRDbGFzc2ljQWRkcmVzcyhhZGRyZXNzKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgZGVjb2RlQWNjb3VudElEKGFkZHJlc3MpO1xuICAgIH1cbiAgICBjYXRjaCAoX2Vycm9yKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG5leHBvcnRzLmlzVmFsaWRDbGFzc2ljQWRkcmVzcyA9IGlzVmFsaWRDbGFzc2ljQWRkcmVzcztcbmZ1bmN0aW9uIGNoZWNrQnl0ZUxlbmd0aChieXRlcywgZXhwZWN0ZWRMZW5ndGgpIHtcbiAgICByZXR1cm4gJ2J5dGVMZW5ndGgnIGluIGJ5dGVzXG4gICAgICAgID8gYnl0ZXMuYnl0ZUxlbmd0aCA9PT0gZXhwZWN0ZWRMZW5ndGhcbiAgICAgICAgOiBieXRlcy5sZW5ndGggPT09IGV4cGVjdGVkTGVuZ3RoO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9eHJwLWNvZGVjLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/xrpl-secret-numbers/node_modules/ripple-address-codec/dist/xrp-codec.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/xrpl-secret-numbers/node_modules/ripple-keypairs/dist/index.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/xrpl-secret-numbers/node_modules/ripple-keypairs/dist/index.js ***!
  \*************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.decodeSeed = exports.deriveNodeAddress = exports.deriveAddress = exports.verify = exports.sign = exports.deriveKeypair = exports.generateSeed = void 0;\nconst ripple_address_codec_1 = __webpack_require__(/*! ripple-address-codec */ \"(ssr)/./node_modules/xrpl-secret-numbers/node_modules/ripple-address-codec/dist/index.js\");\nObject.defineProperty(exports, \"decodeSeed\", ({ enumerable: true, get: function () { return ripple_address_codec_1.decodeSeed; } }));\nconst ripemd160_1 = __webpack_require__(/*! @xrplf/isomorphic/ripemd160 */ \"(ssr)/./node_modules/@xrplf/isomorphic/dist/ripemd160/index.js\");\nconst sha256_1 = __webpack_require__(/*! @xrplf/isomorphic/sha256 */ \"(ssr)/./node_modules/@xrplf/isomorphic/dist/sha256/index.js\");\nconst utils_1 = __webpack_require__(/*! @xrplf/isomorphic/utils */ \"(ssr)/./node_modules/@xrplf/isomorphic/dist/utils/index.js\");\nconst utils_2 = __webpack_require__(/*! ./signing-schemes/secp256k1/utils */ \"(ssr)/./node_modules/xrpl-secret-numbers/node_modules/ripple-keypairs/dist/signing-schemes/secp256k1/utils.js\");\nconst Sha512_1 = __importDefault(__webpack_require__(/*! ./utils/Sha512 */ \"(ssr)/./node_modules/xrpl-secret-numbers/node_modules/ripple-keypairs/dist/utils/Sha512.js\"));\nconst assert_1 = __importDefault(__webpack_require__(/*! ./utils/assert */ \"(ssr)/./node_modules/xrpl-secret-numbers/node_modules/ripple-keypairs/dist/utils/assert.js\"));\nconst getAlgorithmFromKey_1 = __webpack_require__(/*! ./utils/getAlgorithmFromKey */ \"(ssr)/./node_modules/xrpl-secret-numbers/node_modules/ripple-keypairs/dist/utils/getAlgorithmFromKey.js\");\nconst secp256k1_1 = __importDefault(__webpack_require__(/*! ./signing-schemes/secp256k1 */ \"(ssr)/./node_modules/xrpl-secret-numbers/node_modules/ripple-keypairs/dist/signing-schemes/secp256k1/index.js\"));\nconst ed25519_1 = __importDefault(__webpack_require__(/*! ./signing-schemes/ed25519 */ \"(ssr)/./node_modules/xrpl-secret-numbers/node_modules/ripple-keypairs/dist/signing-schemes/ed25519/index.js\"));\nfunction getSigningScheme(algorithm) {\n    const schemes = { 'ecdsa-secp256k1': secp256k1_1.default, ed25519: ed25519_1.default };\n    return schemes[algorithm];\n}\nfunction generateSeed(options = {}) {\n    assert_1.default.ok(!options.entropy || options.entropy.length >= 16, 'entropy too short');\n    const entropy = options.entropy\n        ? options.entropy.slice(0, 16)\n        : (0, utils_1.randomBytes)(16);\n    const type = options.algorithm === 'ed25519' ? 'ed25519' : 'secp256k1';\n    return (0, ripple_address_codec_1.encodeSeed)(entropy, type);\n}\nexports.generateSeed = generateSeed;\nfunction deriveKeypair(seed, options) {\n    var _a;\n    const decoded = (0, ripple_address_codec_1.decodeSeed)(seed);\n    const proposedAlgorithm = (_a = options === null || options === void 0 ? void 0 : options.algorithm) !== null && _a !== void 0 ? _a : decoded.type;\n    const algorithm = proposedAlgorithm === 'ed25519' ? 'ed25519' : 'ecdsa-secp256k1';\n    const scheme = getSigningScheme(algorithm);\n    const keypair = scheme.deriveKeypair(decoded.bytes, options);\n    const messageToVerify = Sha512_1.default.half('This test message should verify.');\n    const signature = scheme.sign(messageToVerify, keypair.privateKey);\n    /* istanbul ignore if */\n    if (!scheme.verify(messageToVerify, signature, keypair.publicKey)) {\n        throw new Error('derived keypair did not generate verifiable signature');\n    }\n    return keypair;\n}\nexports.deriveKeypair = deriveKeypair;\nfunction sign(messageHex, privateKey) {\n    const algorithm = (0, getAlgorithmFromKey_1.getAlgorithmFromPrivateKey)(privateKey);\n    return getSigningScheme(algorithm).sign((0, utils_1.hexToBytes)(messageHex), privateKey);\n}\nexports.sign = sign;\nfunction verify(messageHex, signature, publicKey) {\n    const algorithm = (0, getAlgorithmFromKey_1.getAlgorithmFromPublicKey)(publicKey);\n    return getSigningScheme(algorithm).verify((0, utils_1.hexToBytes)(messageHex), signature, publicKey);\n}\nexports.verify = verify;\nfunction computePublicKeyHash(publicKeyBytes) {\n    return (0, ripemd160_1.ripemd160)((0, sha256_1.sha256)(publicKeyBytes));\n}\nfunction deriveAddressFromBytes(publicKeyBytes) {\n    return (0, ripple_address_codec_1.encodeAccountID)(computePublicKeyHash(publicKeyBytes));\n}\nfunction deriveAddress(publicKey) {\n    return deriveAddressFromBytes((0, utils_1.hexToBytes)(publicKey));\n}\nexports.deriveAddress = deriveAddress;\nfunction deriveNodeAddress(publicKey) {\n    const generatorBytes = (0, ripple_address_codec_1.decodeNodePublic)(publicKey);\n    const accountPublicBytes = (0, utils_2.accountPublicFromPublicGenerator)(generatorBytes);\n    return deriveAddressFromBytes(accountPublicBytes);\n}\nexports.deriveNodeAddress = deriveNodeAddress;\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMveHJwbC1zZWNyZXQtbnVtYmVycy9ub2RlX21vZHVsZXMvcmlwcGxlLWtleXBhaXJzL2Rpc3QvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBLDZDQUE2QztBQUM3QztBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxrQkFBa0IsR0FBRyx5QkFBeUIsR0FBRyxxQkFBcUIsR0FBRyxjQUFjLEdBQUcsWUFBWSxHQUFHLHFCQUFxQixHQUFHLG9CQUFvQjtBQUNySiwrQkFBK0IsbUJBQU8sQ0FBQyxzSEFBc0I7QUFDN0QsOENBQTZDLEVBQUUscUNBQXFDLDZDQUE2QyxFQUFDO0FBQ2xJLG9CQUFvQixtQkFBTyxDQUFDLG1HQUE2QjtBQUN6RCxpQkFBaUIsbUJBQU8sQ0FBQyw2RkFBMEI7QUFDbkQsZ0JBQWdCLG1CQUFPLENBQUMsMkZBQXlCO0FBQ2pELGdCQUFnQixtQkFBTyxDQUFDLHdKQUFtQztBQUMzRCxpQ0FBaUMsbUJBQU8sQ0FBQyxrSEFBZ0I7QUFDekQsaUNBQWlDLG1CQUFPLENBQUMsa0hBQWdCO0FBQ3pELDhCQUE4QixtQkFBTyxDQUFDLDRJQUE2QjtBQUNuRSxvQ0FBb0MsbUJBQU8sQ0FBQyxrSkFBNkI7QUFDekUsa0NBQWtDLG1CQUFPLENBQUMsOElBQTJCO0FBQ3JFO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbWljcm9sZW5kZXIvLi9ub2RlX21vZHVsZXMveHJwbC1zZWNyZXQtbnVtYmVycy9ub2RlX21vZHVsZXMvcmlwcGxlLWtleXBhaXJzL2Rpc3QvaW5kZXguanM/NmFkYSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZGVjb2RlU2VlZCA9IGV4cG9ydHMuZGVyaXZlTm9kZUFkZHJlc3MgPSBleHBvcnRzLmRlcml2ZUFkZHJlc3MgPSBleHBvcnRzLnZlcmlmeSA9IGV4cG9ydHMuc2lnbiA9IGV4cG9ydHMuZGVyaXZlS2V5cGFpciA9IGV4cG9ydHMuZ2VuZXJhdGVTZWVkID0gdm9pZCAwO1xuY29uc3QgcmlwcGxlX2FkZHJlc3NfY29kZWNfMSA9IHJlcXVpcmUoXCJyaXBwbGUtYWRkcmVzcy1jb2RlY1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImRlY29kZVNlZWRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHJpcHBsZV9hZGRyZXNzX2NvZGVjXzEuZGVjb2RlU2VlZDsgfSB9KTtcbmNvbnN0IHJpcGVtZDE2MF8xID0gcmVxdWlyZShcIkB4cnBsZi9pc29tb3JwaGljL3JpcGVtZDE2MFwiKTtcbmNvbnN0IHNoYTI1Nl8xID0gcmVxdWlyZShcIkB4cnBsZi9pc29tb3JwaGljL3NoYTI1NlwiKTtcbmNvbnN0IHV0aWxzXzEgPSByZXF1aXJlKFwiQHhycGxmL2lzb21vcnBoaWMvdXRpbHNcIik7XG5jb25zdCB1dGlsc18yID0gcmVxdWlyZShcIi4vc2lnbmluZy1zY2hlbWVzL3NlY3AyNTZrMS91dGlsc1wiKTtcbmNvbnN0IFNoYTUxMl8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL3V0aWxzL1NoYTUxMlwiKSk7XG5jb25zdCBhc3NlcnRfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi91dGlscy9hc3NlcnRcIikpO1xuY29uc3QgZ2V0QWxnb3JpdGhtRnJvbUtleV8xID0gcmVxdWlyZShcIi4vdXRpbHMvZ2V0QWxnb3JpdGhtRnJvbUtleVwiKTtcbmNvbnN0IHNlY3AyNTZrMV8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL3NpZ25pbmctc2NoZW1lcy9zZWNwMjU2azFcIikpO1xuY29uc3QgZWQyNTUxOV8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL3NpZ25pbmctc2NoZW1lcy9lZDI1NTE5XCIpKTtcbmZ1bmN0aW9uIGdldFNpZ25pbmdTY2hlbWUoYWxnb3JpdGhtKSB7XG4gICAgY29uc3Qgc2NoZW1lcyA9IHsgJ2VjZHNhLXNlY3AyNTZrMSc6IHNlY3AyNTZrMV8xLmRlZmF1bHQsIGVkMjU1MTk6IGVkMjU1MTlfMS5kZWZhdWx0IH07XG4gICAgcmV0dXJuIHNjaGVtZXNbYWxnb3JpdGhtXTtcbn1cbmZ1bmN0aW9uIGdlbmVyYXRlU2VlZChvcHRpb25zID0ge30pIHtcbiAgICBhc3NlcnRfMS5kZWZhdWx0Lm9rKCFvcHRpb25zLmVudHJvcHkgfHwgb3B0aW9ucy5lbnRyb3B5Lmxlbmd0aCA+PSAxNiwgJ2VudHJvcHkgdG9vIHNob3J0Jyk7XG4gICAgY29uc3QgZW50cm9weSA9IG9wdGlvbnMuZW50cm9weVxuICAgICAgICA/IG9wdGlvbnMuZW50cm9weS5zbGljZSgwLCAxNilcbiAgICAgICAgOiAoMCwgdXRpbHNfMS5yYW5kb21CeXRlcykoMTYpO1xuICAgIGNvbnN0IHR5cGUgPSBvcHRpb25zLmFsZ29yaXRobSA9PT0gJ2VkMjU1MTknID8gJ2VkMjU1MTknIDogJ3NlY3AyNTZrMSc7XG4gICAgcmV0dXJuICgwLCByaXBwbGVfYWRkcmVzc19jb2RlY18xLmVuY29kZVNlZWQpKGVudHJvcHksIHR5cGUpO1xufVxuZXhwb3J0cy5nZW5lcmF0ZVNlZWQgPSBnZW5lcmF0ZVNlZWQ7XG5mdW5jdGlvbiBkZXJpdmVLZXlwYWlyKHNlZWQsIG9wdGlvbnMpIHtcbiAgICB2YXIgX2E7XG4gICAgY29uc3QgZGVjb2RlZCA9ICgwLCByaXBwbGVfYWRkcmVzc19jb2RlY18xLmRlY29kZVNlZWQpKHNlZWQpO1xuICAgIGNvbnN0IHByb3Bvc2VkQWxnb3JpdGhtID0gKF9hID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmFsZ29yaXRobSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogZGVjb2RlZC50eXBlO1xuICAgIGNvbnN0IGFsZ29yaXRobSA9IHByb3Bvc2VkQWxnb3JpdGhtID09PSAnZWQyNTUxOScgPyAnZWQyNTUxOScgOiAnZWNkc2Etc2VjcDI1NmsxJztcbiAgICBjb25zdCBzY2hlbWUgPSBnZXRTaWduaW5nU2NoZW1lKGFsZ29yaXRobSk7XG4gICAgY29uc3Qga2V5cGFpciA9IHNjaGVtZS5kZXJpdmVLZXlwYWlyKGRlY29kZWQuYnl0ZXMsIG9wdGlvbnMpO1xuICAgIGNvbnN0IG1lc3NhZ2VUb1ZlcmlmeSA9IFNoYTUxMl8xLmRlZmF1bHQuaGFsZignVGhpcyB0ZXN0IG1lc3NhZ2Ugc2hvdWxkIHZlcmlmeS4nKTtcbiAgICBjb25zdCBzaWduYXR1cmUgPSBzY2hlbWUuc2lnbihtZXNzYWdlVG9WZXJpZnksIGtleXBhaXIucHJpdmF0ZUtleSk7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKCFzY2hlbWUudmVyaWZ5KG1lc3NhZ2VUb1ZlcmlmeSwgc2lnbmF0dXJlLCBrZXlwYWlyLnB1YmxpY0tleSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdkZXJpdmVkIGtleXBhaXIgZGlkIG5vdCBnZW5lcmF0ZSB2ZXJpZmlhYmxlIHNpZ25hdHVyZScpO1xuICAgIH1cbiAgICByZXR1cm4ga2V5cGFpcjtcbn1cbmV4cG9ydHMuZGVyaXZlS2V5cGFpciA9IGRlcml2ZUtleXBhaXI7XG5mdW5jdGlvbiBzaWduKG1lc3NhZ2VIZXgsIHByaXZhdGVLZXkpIHtcbiAgICBjb25zdCBhbGdvcml0aG0gPSAoMCwgZ2V0QWxnb3JpdGhtRnJvbUtleV8xLmdldEFsZ29yaXRobUZyb21Qcml2YXRlS2V5KShwcml2YXRlS2V5KTtcbiAgICByZXR1cm4gZ2V0U2lnbmluZ1NjaGVtZShhbGdvcml0aG0pLnNpZ24oKDAsIHV0aWxzXzEuaGV4VG9CeXRlcykobWVzc2FnZUhleCksIHByaXZhdGVLZXkpO1xufVxuZXhwb3J0cy5zaWduID0gc2lnbjtcbmZ1bmN0aW9uIHZlcmlmeShtZXNzYWdlSGV4LCBzaWduYXR1cmUsIHB1YmxpY0tleSkge1xuICAgIGNvbnN0IGFsZ29yaXRobSA9ICgwLCBnZXRBbGdvcml0aG1Gcm9tS2V5XzEuZ2V0QWxnb3JpdGhtRnJvbVB1YmxpY0tleSkocHVibGljS2V5KTtcbiAgICByZXR1cm4gZ2V0U2lnbmluZ1NjaGVtZShhbGdvcml0aG0pLnZlcmlmeSgoMCwgdXRpbHNfMS5oZXhUb0J5dGVzKShtZXNzYWdlSGV4KSwgc2lnbmF0dXJlLCBwdWJsaWNLZXkpO1xufVxuZXhwb3J0cy52ZXJpZnkgPSB2ZXJpZnk7XG5mdW5jdGlvbiBjb21wdXRlUHVibGljS2V5SGFzaChwdWJsaWNLZXlCeXRlcykge1xuICAgIHJldHVybiAoMCwgcmlwZW1kMTYwXzEucmlwZW1kMTYwKSgoMCwgc2hhMjU2XzEuc2hhMjU2KShwdWJsaWNLZXlCeXRlcykpO1xufVxuZnVuY3Rpb24gZGVyaXZlQWRkcmVzc0Zyb21CeXRlcyhwdWJsaWNLZXlCeXRlcykge1xuICAgIHJldHVybiAoMCwgcmlwcGxlX2FkZHJlc3NfY29kZWNfMS5lbmNvZGVBY2NvdW50SUQpKGNvbXB1dGVQdWJsaWNLZXlIYXNoKHB1YmxpY0tleUJ5dGVzKSk7XG59XG5mdW5jdGlvbiBkZXJpdmVBZGRyZXNzKHB1YmxpY0tleSkge1xuICAgIHJldHVybiBkZXJpdmVBZGRyZXNzRnJvbUJ5dGVzKCgwLCB1dGlsc18xLmhleFRvQnl0ZXMpKHB1YmxpY0tleSkpO1xufVxuZXhwb3J0cy5kZXJpdmVBZGRyZXNzID0gZGVyaXZlQWRkcmVzcztcbmZ1bmN0aW9uIGRlcml2ZU5vZGVBZGRyZXNzKHB1YmxpY0tleSkge1xuICAgIGNvbnN0IGdlbmVyYXRvckJ5dGVzID0gKDAsIHJpcHBsZV9hZGRyZXNzX2NvZGVjXzEuZGVjb2RlTm9kZVB1YmxpYykocHVibGljS2V5KTtcbiAgICBjb25zdCBhY2NvdW50UHVibGljQnl0ZXMgPSAoMCwgdXRpbHNfMi5hY2NvdW50UHVibGljRnJvbVB1YmxpY0dlbmVyYXRvcikoZ2VuZXJhdG9yQnl0ZXMpO1xuICAgIHJldHVybiBkZXJpdmVBZGRyZXNzRnJvbUJ5dGVzKGFjY291bnRQdWJsaWNCeXRlcyk7XG59XG5leHBvcnRzLmRlcml2ZU5vZGVBZGRyZXNzID0gZGVyaXZlTm9kZUFkZHJlc3M7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/xrpl-secret-numbers/node_modules/ripple-keypairs/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/xrpl-secret-numbers/node_modules/ripple-keypairs/dist/signing-schemes/ed25519/index.js":
/*!*************************************************************************************************************!*\
  !*** ./node_modules/xrpl-secret-numbers/node_modules/ripple-keypairs/dist/signing-schemes/ed25519/index.js ***!
  \*************************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst ed25519_1 = __webpack_require__(/*! @noble/curves/ed25519 */ \"(ssr)/./node_modules/@noble/curves/ed25519.js\");\nconst utils_1 = __webpack_require__(/*! @xrplf/isomorphic/utils */ \"(ssr)/./node_modules/@xrplf/isomorphic/dist/utils/index.js\");\nconst assert_1 = __importDefault(__webpack_require__(/*! ../../utils/assert */ \"(ssr)/./node_modules/xrpl-secret-numbers/node_modules/ripple-keypairs/dist/utils/assert.js\"));\nconst Sha512_1 = __importDefault(__webpack_require__(/*! ../../utils/Sha512 */ \"(ssr)/./node_modules/xrpl-secret-numbers/node_modules/ripple-keypairs/dist/utils/Sha512.js\"));\nconst ED_PREFIX = 'ED';\nconst ed25519 = {\n    deriveKeypair(entropy) {\n        const rawPrivateKey = Sha512_1.default.half(entropy);\n        const privateKey = ED_PREFIX + (0, utils_1.bytesToHex)(rawPrivateKey);\n        const publicKey = ED_PREFIX + (0, utils_1.bytesToHex)(ed25519_1.ed25519.getPublicKey(rawPrivateKey));\n        return { privateKey, publicKey };\n    },\n    sign(message, privateKey) {\n        assert_1.default.ok(message instanceof Uint8Array, 'message must be array of octets');\n        assert_1.default.ok(privateKey.length === 66, 'private key must be 33 bytes including prefix');\n        return (0, utils_1.bytesToHex)(ed25519_1.ed25519.sign(message, privateKey.slice(2)));\n    },\n    verify(message, signature, publicKey) {\n        // Unlikely to be triggered as these are internal and guarded by getAlgorithmFromKey\n        assert_1.default.ok(publicKey.length === 66, 'public key must be 33 bytes including prefix');\n        return ed25519_1.ed25519.verify(signature, message, \n        // Remove the 0xED prefix\n        publicKey.slice(2), \n        // By default, set zip215 to false for compatibility reasons.\n        // ZIP 215 is a stricter Ed25519 signature verification scheme.\n        // However, setting it to false adheres to the more commonly used\n        // RFC8032 / NIST186-5 standards, making it compatible with systems\n        // like the XRP Ledger.\n        { zip215: false });\n    },\n};\nexports[\"default\"] = ed25519;\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMveHJwbC1zZWNyZXQtbnVtYmVycy9ub2RlX21vZHVsZXMvcmlwcGxlLWtleXBhaXJzL2Rpc3Qvc2lnbmluZy1zY2hlbWVzL2VkMjU1MTkvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBLDZDQUE2QztBQUM3QztBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxrQkFBa0IsbUJBQU8sQ0FBQyw0RUFBdUI7QUFDakQsZ0JBQWdCLG1CQUFPLENBQUMsMkZBQXlCO0FBQ2pELGlDQUFpQyxtQkFBTyxDQUFDLHNIQUFvQjtBQUM3RCxpQ0FBaUMsbUJBQU8sQ0FBQyxzSEFBb0I7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxlQUFlO0FBQ3pCLEtBQUs7QUFDTDtBQUNBLGtCQUFlO0FBQ2YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9taWNyb2xlbmRlci8uL25vZGVfbW9kdWxlcy94cnBsLXNlY3JldC1udW1iZXJzL25vZGVfbW9kdWxlcy9yaXBwbGUta2V5cGFpcnMvZGlzdC9zaWduaW5nLXNjaGVtZXMvZWQyNTUxOS9pbmRleC5qcz8xNTgxIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgZWQyNTUxOV8xID0gcmVxdWlyZShcIkBub2JsZS9jdXJ2ZXMvZWQyNTUxOVwiKTtcbmNvbnN0IHV0aWxzXzEgPSByZXF1aXJlKFwiQHhycGxmL2lzb21vcnBoaWMvdXRpbHNcIik7XG5jb25zdCBhc3NlcnRfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi4vLi4vdXRpbHMvYXNzZXJ0XCIpKTtcbmNvbnN0IFNoYTUxMl8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuLi8uLi91dGlscy9TaGE1MTJcIikpO1xuY29uc3QgRURfUFJFRklYID0gJ0VEJztcbmNvbnN0IGVkMjU1MTkgPSB7XG4gICAgZGVyaXZlS2V5cGFpcihlbnRyb3B5KSB7XG4gICAgICAgIGNvbnN0IHJhd1ByaXZhdGVLZXkgPSBTaGE1MTJfMS5kZWZhdWx0LmhhbGYoZW50cm9weSk7XG4gICAgICAgIGNvbnN0IHByaXZhdGVLZXkgPSBFRF9QUkVGSVggKyAoMCwgdXRpbHNfMS5ieXRlc1RvSGV4KShyYXdQcml2YXRlS2V5KTtcbiAgICAgICAgY29uc3QgcHVibGljS2V5ID0gRURfUFJFRklYICsgKDAsIHV0aWxzXzEuYnl0ZXNUb0hleCkoZWQyNTUxOV8xLmVkMjU1MTkuZ2V0UHVibGljS2V5KHJhd1ByaXZhdGVLZXkpKTtcbiAgICAgICAgcmV0dXJuIHsgcHJpdmF0ZUtleSwgcHVibGljS2V5IH07XG4gICAgfSxcbiAgICBzaWduKG1lc3NhZ2UsIHByaXZhdGVLZXkpIHtcbiAgICAgICAgYXNzZXJ0XzEuZGVmYXVsdC5vayhtZXNzYWdlIGluc3RhbmNlb2YgVWludDhBcnJheSwgJ21lc3NhZ2UgbXVzdCBiZSBhcnJheSBvZiBvY3RldHMnKTtcbiAgICAgICAgYXNzZXJ0XzEuZGVmYXVsdC5vayhwcml2YXRlS2V5Lmxlbmd0aCA9PT0gNjYsICdwcml2YXRlIGtleSBtdXN0IGJlIDMzIGJ5dGVzIGluY2x1ZGluZyBwcmVmaXgnKTtcbiAgICAgICAgcmV0dXJuICgwLCB1dGlsc18xLmJ5dGVzVG9IZXgpKGVkMjU1MTlfMS5lZDI1NTE5LnNpZ24obWVzc2FnZSwgcHJpdmF0ZUtleS5zbGljZSgyKSkpO1xuICAgIH0sXG4gICAgdmVyaWZ5KG1lc3NhZ2UsIHNpZ25hdHVyZSwgcHVibGljS2V5KSB7XG4gICAgICAgIC8vIFVubGlrZWx5IHRvIGJlIHRyaWdnZXJlZCBhcyB0aGVzZSBhcmUgaW50ZXJuYWwgYW5kIGd1YXJkZWQgYnkgZ2V0QWxnb3JpdGhtRnJvbUtleVxuICAgICAgICBhc3NlcnRfMS5kZWZhdWx0Lm9rKHB1YmxpY0tleS5sZW5ndGggPT09IDY2LCAncHVibGljIGtleSBtdXN0IGJlIDMzIGJ5dGVzIGluY2x1ZGluZyBwcmVmaXgnKTtcbiAgICAgICAgcmV0dXJuIGVkMjU1MTlfMS5lZDI1NTE5LnZlcmlmeShzaWduYXR1cmUsIG1lc3NhZ2UsIFxuICAgICAgICAvLyBSZW1vdmUgdGhlIDB4RUQgcHJlZml4XG4gICAgICAgIHB1YmxpY0tleS5zbGljZSgyKSwgXG4gICAgICAgIC8vIEJ5IGRlZmF1bHQsIHNldCB6aXAyMTUgdG8gZmFsc2UgZm9yIGNvbXBhdGliaWxpdHkgcmVhc29ucy5cbiAgICAgICAgLy8gWklQIDIxNSBpcyBhIHN0cmljdGVyIEVkMjU1MTkgc2lnbmF0dXJlIHZlcmlmaWNhdGlvbiBzY2hlbWUuXG4gICAgICAgIC8vIEhvd2V2ZXIsIHNldHRpbmcgaXQgdG8gZmFsc2UgYWRoZXJlcyB0byB0aGUgbW9yZSBjb21tb25seSB1c2VkXG4gICAgICAgIC8vIFJGQzgwMzIgLyBOSVNUMTg2LTUgc3RhbmRhcmRzLCBtYWtpbmcgaXQgY29tcGF0aWJsZSB3aXRoIHN5c3RlbXNcbiAgICAgICAgLy8gbGlrZSB0aGUgWFJQIExlZGdlci5cbiAgICAgICAgeyB6aXAyMTU6IGZhbHNlIH0pO1xuICAgIH0sXG59O1xuZXhwb3J0cy5kZWZhdWx0ID0gZWQyNTUxOTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/xrpl-secret-numbers/node_modules/ripple-keypairs/dist/signing-schemes/ed25519/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/xrpl-secret-numbers/node_modules/ripple-keypairs/dist/signing-schemes/secp256k1/index.js":
/*!***************************************************************************************************************!*\
  !*** ./node_modules/xrpl-secret-numbers/node_modules/ripple-keypairs/dist/signing-schemes/secp256k1/index.js ***!
  \***************************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst utils_1 = __webpack_require__(/*! @noble/curves/abstract/utils */ \"(ssr)/./node_modules/@noble/curves/abstract/utils.js\");\nconst secp256k1_1 = __webpack_require__(/*! @noble/curves/secp256k1 */ \"(ssr)/./node_modules/@noble/curves/secp256k1.js\");\nconst utils_2 = __webpack_require__(/*! @xrplf/isomorphic/utils */ \"(ssr)/./node_modules/@xrplf/isomorphic/dist/utils/index.js\");\nconst utils_3 = __webpack_require__(/*! ./utils */ \"(ssr)/./node_modules/xrpl-secret-numbers/node_modules/ripple-keypairs/dist/signing-schemes/secp256k1/utils.js\");\nconst assert_1 = __importDefault(__webpack_require__(/*! ../../utils/assert */ \"(ssr)/./node_modules/xrpl-secret-numbers/node_modules/ripple-keypairs/dist/utils/assert.js\"));\nconst Sha512_1 = __importDefault(__webpack_require__(/*! ../../utils/Sha512 */ \"(ssr)/./node_modules/xrpl-secret-numbers/node_modules/ripple-keypairs/dist/utils/Sha512.js\"));\nconst SECP256K1_PREFIX = '00';\nconst secp256k1 = {\n    deriveKeypair(entropy, options) {\n        const derived = (0, utils_3.derivePrivateKey)(entropy, options);\n        const privateKey = SECP256K1_PREFIX + (0, utils_2.bytesToHex)((0, utils_1.numberToBytesBE)(derived, 32));\n        const publicKey = (0, utils_2.bytesToHex)(secp256k1_1.secp256k1.getPublicKey(derived, true));\n        return { privateKey, publicKey };\n    },\n    sign(message, privateKey) {\n        // Some callers pass the privateKey with the prefix, others without.\n        // @noble/curves will throw if the key is not exactly 32 bytes, so we\n        // normalize it before passing to the sign method.\n        assert_1.default.ok((privateKey.length === 66 && privateKey.startsWith(SECP256K1_PREFIX)) ||\n            privateKey.length === 64);\n        const normedPrivateKey = privateKey.length === 66 ? privateKey.slice(2) : privateKey;\n        return secp256k1_1.secp256k1\n            .sign(Sha512_1.default.half(message), normedPrivateKey, {\n            // \"Canonical\" signatures\n            lowS: true,\n            // Would fail tests if signatures aren't deterministic\n            extraEntropy: undefined,\n        })\n            .toDERHex(true)\n            .toUpperCase();\n    },\n    verify(message, signature, publicKey) {\n        const decoded = secp256k1_1.secp256k1.Signature.fromDER(signature);\n        return secp256k1_1.secp256k1.verify(decoded, Sha512_1.default.half(message), publicKey);\n    },\n};\nexports[\"default\"] = secp256k1;\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMveHJwbC1zZWNyZXQtbnVtYmVycy9ub2RlX21vZHVsZXMvcmlwcGxlLWtleXBhaXJzL2Rpc3Qvc2lnbmluZy1zY2hlbWVzL3NlY3AyNTZrMS9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGdCQUFnQixtQkFBTyxDQUFDLDBGQUE4QjtBQUN0RCxvQkFBb0IsbUJBQU8sQ0FBQyxnRkFBeUI7QUFDckQsZ0JBQWdCLG1CQUFPLENBQUMsMkZBQXlCO0FBQ2pELGdCQUFnQixtQkFBTyxDQUFDLDhIQUFTO0FBQ2pDLGlDQUFpQyxtQkFBTyxDQUFDLHNIQUFvQjtBQUM3RCxpQ0FBaUMsbUJBQU8sQ0FBQyxzSEFBb0I7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLGtCQUFlO0FBQ2YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9taWNyb2xlbmRlci8uL25vZGVfbW9kdWxlcy94cnBsLXNlY3JldC1udW1iZXJzL25vZGVfbW9kdWxlcy9yaXBwbGUta2V5cGFpcnMvZGlzdC9zaWduaW5nLXNjaGVtZXMvc2VjcDI1NmsxL2luZGV4LmpzP2E1ZDciXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCB1dGlsc18xID0gcmVxdWlyZShcIkBub2JsZS9jdXJ2ZXMvYWJzdHJhY3QvdXRpbHNcIik7XG5jb25zdCBzZWNwMjU2azFfMSA9IHJlcXVpcmUoXCJAbm9ibGUvY3VydmVzL3NlY3AyNTZrMVwiKTtcbmNvbnN0IHV0aWxzXzIgPSByZXF1aXJlKFwiQHhycGxmL2lzb21vcnBoaWMvdXRpbHNcIik7XG5jb25zdCB1dGlsc18zID0gcmVxdWlyZShcIi4vdXRpbHNcIik7XG5jb25zdCBhc3NlcnRfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi4vLi4vdXRpbHMvYXNzZXJ0XCIpKTtcbmNvbnN0IFNoYTUxMl8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuLi8uLi91dGlscy9TaGE1MTJcIikpO1xuY29uc3QgU0VDUDI1NksxX1BSRUZJWCA9ICcwMCc7XG5jb25zdCBzZWNwMjU2azEgPSB7XG4gICAgZGVyaXZlS2V5cGFpcihlbnRyb3B5LCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGRlcml2ZWQgPSAoMCwgdXRpbHNfMy5kZXJpdmVQcml2YXRlS2V5KShlbnRyb3B5LCBvcHRpb25zKTtcbiAgICAgICAgY29uc3QgcHJpdmF0ZUtleSA9IFNFQ1AyNTZLMV9QUkVGSVggKyAoMCwgdXRpbHNfMi5ieXRlc1RvSGV4KSgoMCwgdXRpbHNfMS5udW1iZXJUb0J5dGVzQkUpKGRlcml2ZWQsIDMyKSk7XG4gICAgICAgIGNvbnN0IHB1YmxpY0tleSA9ICgwLCB1dGlsc18yLmJ5dGVzVG9IZXgpKHNlY3AyNTZrMV8xLnNlY3AyNTZrMS5nZXRQdWJsaWNLZXkoZGVyaXZlZCwgdHJ1ZSkpO1xuICAgICAgICByZXR1cm4geyBwcml2YXRlS2V5LCBwdWJsaWNLZXkgfTtcbiAgICB9LFxuICAgIHNpZ24obWVzc2FnZSwgcHJpdmF0ZUtleSkge1xuICAgICAgICAvLyBTb21lIGNhbGxlcnMgcGFzcyB0aGUgcHJpdmF0ZUtleSB3aXRoIHRoZSBwcmVmaXgsIG90aGVycyB3aXRob3V0LlxuICAgICAgICAvLyBAbm9ibGUvY3VydmVzIHdpbGwgdGhyb3cgaWYgdGhlIGtleSBpcyBub3QgZXhhY3RseSAzMiBieXRlcywgc28gd2VcbiAgICAgICAgLy8gbm9ybWFsaXplIGl0IGJlZm9yZSBwYXNzaW5nIHRvIHRoZSBzaWduIG1ldGhvZC5cbiAgICAgICAgYXNzZXJ0XzEuZGVmYXVsdC5vaygocHJpdmF0ZUtleS5sZW5ndGggPT09IDY2ICYmIHByaXZhdGVLZXkuc3RhcnRzV2l0aChTRUNQMjU2SzFfUFJFRklYKSkgfHxcbiAgICAgICAgICAgIHByaXZhdGVLZXkubGVuZ3RoID09PSA2NCk7XG4gICAgICAgIGNvbnN0IG5vcm1lZFByaXZhdGVLZXkgPSBwcml2YXRlS2V5Lmxlbmd0aCA9PT0gNjYgPyBwcml2YXRlS2V5LnNsaWNlKDIpIDogcHJpdmF0ZUtleTtcbiAgICAgICAgcmV0dXJuIHNlY3AyNTZrMV8xLnNlY3AyNTZrMVxuICAgICAgICAgICAgLnNpZ24oU2hhNTEyXzEuZGVmYXVsdC5oYWxmKG1lc3NhZ2UpLCBub3JtZWRQcml2YXRlS2V5LCB7XG4gICAgICAgICAgICAvLyBcIkNhbm9uaWNhbFwiIHNpZ25hdHVyZXNcbiAgICAgICAgICAgIGxvd1M6IHRydWUsXG4gICAgICAgICAgICAvLyBXb3VsZCBmYWlsIHRlc3RzIGlmIHNpZ25hdHVyZXMgYXJlbid0IGRldGVybWluaXN0aWNcbiAgICAgICAgICAgIGV4dHJhRW50cm9weTogdW5kZWZpbmVkLFxuICAgICAgICB9KVxuICAgICAgICAgICAgLnRvREVSSGV4KHRydWUpXG4gICAgICAgICAgICAudG9VcHBlckNhc2UoKTtcbiAgICB9LFxuICAgIHZlcmlmeShtZXNzYWdlLCBzaWduYXR1cmUsIHB1YmxpY0tleSkge1xuICAgICAgICBjb25zdCBkZWNvZGVkID0gc2VjcDI1NmsxXzEuc2VjcDI1NmsxLlNpZ25hdHVyZS5mcm9tREVSKHNpZ25hdHVyZSk7XG4gICAgICAgIHJldHVybiBzZWNwMjU2azFfMS5zZWNwMjU2azEudmVyaWZ5KGRlY29kZWQsIFNoYTUxMl8xLmRlZmF1bHQuaGFsZihtZXNzYWdlKSwgcHVibGljS2V5KTtcbiAgICB9LFxufTtcbmV4cG9ydHMuZGVmYXVsdCA9IHNlY3AyNTZrMTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/xrpl-secret-numbers/node_modules/ripple-keypairs/dist/signing-schemes/secp256k1/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/xrpl-secret-numbers/node_modules/ripple-keypairs/dist/signing-schemes/secp256k1/utils.js":
/*!***************************************************************************************************************!*\
  !*** ./node_modules/xrpl-secret-numbers/node_modules/ripple-keypairs/dist/signing-schemes/secp256k1/utils.js ***!
  \***************************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.accountPublicFromPublicGenerator = exports.derivePrivateKey = void 0;\nconst secp256k1_1 = __webpack_require__(/*! @noble/curves/secp256k1 */ \"(ssr)/./node_modules/@noble/curves/secp256k1.js\");\nconst Sha512_1 = __importDefault(__webpack_require__(/*! ../../utils/Sha512 */ \"(ssr)/./node_modules/xrpl-secret-numbers/node_modules/ripple-keypairs/dist/utils/Sha512.js\"));\nconst ZERO = BigInt(0);\nfunction deriveScalar(bytes, discrim) {\n    const order = secp256k1_1.secp256k1.CURVE.n;\n    for (let i = 0; i <= 4294967295; i++) {\n        // We hash the bytes to find a 256-bit number, looping until we are sure it\n        // is less than the order of the curve.\n        const hasher = new Sha512_1.default().add(bytes);\n        // If the optional discriminator index was passed in, update the hash.\n        if (discrim !== undefined) {\n            hasher.addU32(discrim);\n        }\n        hasher.addU32(i);\n        const key = hasher.first256BigInt();\n        /* istanbul ignore else */\n        if (key > ZERO && key < order) {\n            return key;\n        }\n    }\n    // This error is practically impossible to reach.\n    // The order of the curve describes the (finite) amount of points on the curve\n    // https://github.com/indutny/elliptic/blob/master/lib/elliptic/curves.js#L182\n    // How often will an (essentially) random number generated by Sha512 be larger than that?\n    // There's 2^32 chances (the for loop) to get a number smaller than the order,\n    // and it's rare that you'll even get past the first loop iteration.\n    // Note that in TypeScript we actually need the throw, otherwise the function signature would be bigint | undefined\n    //\n    /* istanbul ignore next */\n    throw new Error('impossible unicorn ;)');\n}\n/**\n * @param seed - Bytes.\n * @param [opts] - Object.\n * @param [opts.accountIndex=0] - The account number to generate.\n * @param [opts.validator=false] - Generate root key-pair,\n *                                              as used by validators.\n * @returns {bigint} 256 bit scalar value.\n *\n */\nfunction derivePrivateKey(seed, opts = {}) {\n    const root = opts.validator;\n    const order = secp256k1_1.secp256k1.CURVE.n;\n    // This private generator represents the `root` private key, and is what's\n    // used by validators for signing when a keypair is generated from a seed.\n    const privateGen = deriveScalar(seed);\n    if (root) {\n        // As returned by validation_create for a given seed\n        return privateGen;\n    }\n    const publicGen = secp256k1_1.secp256k1.ProjectivePoint.BASE.multiply(privateGen).toRawBytes(true);\n    // A seed can generate many keypairs as a function of the seed and a uint32.\n    // Almost everyone just uses the first account, `0`.\n    const accountIndex = opts.accountIndex || 0;\n    return (deriveScalar(publicGen, accountIndex) + privateGen) % order;\n}\nexports.derivePrivateKey = derivePrivateKey;\nfunction accountPublicFromPublicGenerator(publicGenBytes) {\n    const rootPubPoint = secp256k1_1.secp256k1.ProjectivePoint.fromHex(publicGenBytes);\n    const scalar = deriveScalar(publicGenBytes, 0);\n    const point = secp256k1_1.secp256k1.ProjectivePoint.BASE.multiply(scalar);\n    const offset = rootPubPoint.add(point);\n    return offset.toRawBytes(true);\n}\nexports.accountPublicFromPublicGenerator = accountPublicFromPublicGenerator;\n//# sourceMappingURL=utils.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMveHJwbC1zZWNyZXQtbnVtYmVycy9ub2RlX21vZHVsZXMvcmlwcGxlLWtleXBhaXJzL2Rpc3Qvc2lnbmluZy1zY2hlbWVzL3NlY3AyNTZrMS91dGlscy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHdDQUF3QyxHQUFHLHdCQUF3QjtBQUNuRSxvQkFBb0IsbUJBQU8sQ0FBQyxnRkFBeUI7QUFDckQsaUNBQWlDLG1CQUFPLENBQUMsc0hBQW9CO0FBQzdEO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixpQkFBaUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QztBQUN4QyIsInNvdXJjZXMiOlsid2VicGFjazovL21pY3JvbGVuZGVyLy4vbm9kZV9tb2R1bGVzL3hycGwtc2VjcmV0LW51bWJlcnMvbm9kZV9tb2R1bGVzL3JpcHBsZS1rZXlwYWlycy9kaXN0L3NpZ25pbmctc2NoZW1lcy9zZWNwMjU2azEvdXRpbHMuanM/ZGE1YSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuYWNjb3VudFB1YmxpY0Zyb21QdWJsaWNHZW5lcmF0b3IgPSBleHBvcnRzLmRlcml2ZVByaXZhdGVLZXkgPSB2b2lkIDA7XG5jb25zdCBzZWNwMjU2azFfMSA9IHJlcXVpcmUoXCJAbm9ibGUvY3VydmVzL3NlY3AyNTZrMVwiKTtcbmNvbnN0IFNoYTUxMl8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuLi8uLi91dGlscy9TaGE1MTJcIikpO1xuY29uc3QgWkVSTyA9IEJpZ0ludCgwKTtcbmZ1bmN0aW9uIGRlcml2ZVNjYWxhcihieXRlcywgZGlzY3JpbSkge1xuICAgIGNvbnN0IG9yZGVyID0gc2VjcDI1NmsxXzEuc2VjcDI1NmsxLkNVUlZFLm47XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPD0gNDI5NDk2NzI5NTsgaSsrKSB7XG4gICAgICAgIC8vIFdlIGhhc2ggdGhlIGJ5dGVzIHRvIGZpbmQgYSAyNTYtYml0IG51bWJlciwgbG9vcGluZyB1bnRpbCB3ZSBhcmUgc3VyZSBpdFxuICAgICAgICAvLyBpcyBsZXNzIHRoYW4gdGhlIG9yZGVyIG9mIHRoZSBjdXJ2ZS5cbiAgICAgICAgY29uc3QgaGFzaGVyID0gbmV3IFNoYTUxMl8xLmRlZmF1bHQoKS5hZGQoYnl0ZXMpO1xuICAgICAgICAvLyBJZiB0aGUgb3B0aW9uYWwgZGlzY3JpbWluYXRvciBpbmRleCB3YXMgcGFzc2VkIGluLCB1cGRhdGUgdGhlIGhhc2guXG4gICAgICAgIGlmIChkaXNjcmltICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGhhc2hlci5hZGRVMzIoZGlzY3JpbSk7XG4gICAgICAgIH1cbiAgICAgICAgaGFzaGVyLmFkZFUzMihpKTtcbiAgICAgICAgY29uc3Qga2V5ID0gaGFzaGVyLmZpcnN0MjU2QmlnSW50KCk7XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgICAgIGlmIChrZXkgPiBaRVJPICYmIGtleSA8IG9yZGVyKSB7XG4gICAgICAgICAgICByZXR1cm4ga2V5O1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIFRoaXMgZXJyb3IgaXMgcHJhY3RpY2FsbHkgaW1wb3NzaWJsZSB0byByZWFjaC5cbiAgICAvLyBUaGUgb3JkZXIgb2YgdGhlIGN1cnZlIGRlc2NyaWJlcyB0aGUgKGZpbml0ZSkgYW1vdW50IG9mIHBvaW50cyBvbiB0aGUgY3VydmVcbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vaW5kdXRueS9lbGxpcHRpYy9ibG9iL21hc3Rlci9saWIvZWxsaXB0aWMvY3VydmVzLmpzI0wxODJcbiAgICAvLyBIb3cgb2Z0ZW4gd2lsbCBhbiAoZXNzZW50aWFsbHkpIHJhbmRvbSBudW1iZXIgZ2VuZXJhdGVkIGJ5IFNoYTUxMiBiZSBsYXJnZXIgdGhhbiB0aGF0P1xuICAgIC8vIFRoZXJlJ3MgMl4zMiBjaGFuY2VzICh0aGUgZm9yIGxvb3ApIHRvIGdldCBhIG51bWJlciBzbWFsbGVyIHRoYW4gdGhlIG9yZGVyLFxuICAgIC8vIGFuZCBpdCdzIHJhcmUgdGhhdCB5b3UnbGwgZXZlbiBnZXQgcGFzdCB0aGUgZmlyc3QgbG9vcCBpdGVyYXRpb24uXG4gICAgLy8gTm90ZSB0aGF0IGluIFR5cGVTY3JpcHQgd2UgYWN0dWFsbHkgbmVlZCB0aGUgdGhyb3csIG90aGVyd2lzZSB0aGUgZnVuY3Rpb24gc2lnbmF0dXJlIHdvdWxkIGJlIGJpZ2ludCB8IHVuZGVmaW5lZFxuICAgIC8vXG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2ltcG9zc2libGUgdW5pY29ybiA7KScpO1xufVxuLyoqXG4gKiBAcGFyYW0gc2VlZCAtIEJ5dGVzLlxuICogQHBhcmFtIFtvcHRzXSAtIE9iamVjdC5cbiAqIEBwYXJhbSBbb3B0cy5hY2NvdW50SW5kZXg9MF0gLSBUaGUgYWNjb3VudCBudW1iZXIgdG8gZ2VuZXJhdGUuXG4gKiBAcGFyYW0gW29wdHMudmFsaWRhdG9yPWZhbHNlXSAtIEdlbmVyYXRlIHJvb3Qga2V5LXBhaXIsXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcyB1c2VkIGJ5IHZhbGlkYXRvcnMuXG4gKiBAcmV0dXJucyB7YmlnaW50fSAyNTYgYml0IHNjYWxhciB2YWx1ZS5cbiAqXG4gKi9cbmZ1bmN0aW9uIGRlcml2ZVByaXZhdGVLZXkoc2VlZCwgb3B0cyA9IHt9KSB7XG4gICAgY29uc3Qgcm9vdCA9IG9wdHMudmFsaWRhdG9yO1xuICAgIGNvbnN0IG9yZGVyID0gc2VjcDI1NmsxXzEuc2VjcDI1NmsxLkNVUlZFLm47XG4gICAgLy8gVGhpcyBwcml2YXRlIGdlbmVyYXRvciByZXByZXNlbnRzIHRoZSBgcm9vdGAgcHJpdmF0ZSBrZXksIGFuZCBpcyB3aGF0J3NcbiAgICAvLyB1c2VkIGJ5IHZhbGlkYXRvcnMgZm9yIHNpZ25pbmcgd2hlbiBhIGtleXBhaXIgaXMgZ2VuZXJhdGVkIGZyb20gYSBzZWVkLlxuICAgIGNvbnN0IHByaXZhdGVHZW4gPSBkZXJpdmVTY2FsYXIoc2VlZCk7XG4gICAgaWYgKHJvb3QpIHtcbiAgICAgICAgLy8gQXMgcmV0dXJuZWQgYnkgdmFsaWRhdGlvbl9jcmVhdGUgZm9yIGEgZ2l2ZW4gc2VlZFxuICAgICAgICByZXR1cm4gcHJpdmF0ZUdlbjtcbiAgICB9XG4gICAgY29uc3QgcHVibGljR2VuID0gc2VjcDI1NmsxXzEuc2VjcDI1NmsxLlByb2plY3RpdmVQb2ludC5CQVNFLm11bHRpcGx5KHByaXZhdGVHZW4pLnRvUmF3Qnl0ZXModHJ1ZSk7XG4gICAgLy8gQSBzZWVkIGNhbiBnZW5lcmF0ZSBtYW55IGtleXBhaXJzIGFzIGEgZnVuY3Rpb24gb2YgdGhlIHNlZWQgYW5kIGEgdWludDMyLlxuICAgIC8vIEFsbW9zdCBldmVyeW9uZSBqdXN0IHVzZXMgdGhlIGZpcnN0IGFjY291bnQsIGAwYC5cbiAgICBjb25zdCBhY2NvdW50SW5kZXggPSBvcHRzLmFjY291bnRJbmRleCB8fCAwO1xuICAgIHJldHVybiAoZGVyaXZlU2NhbGFyKHB1YmxpY0dlbiwgYWNjb3VudEluZGV4KSArIHByaXZhdGVHZW4pICUgb3JkZXI7XG59XG5leHBvcnRzLmRlcml2ZVByaXZhdGVLZXkgPSBkZXJpdmVQcml2YXRlS2V5O1xuZnVuY3Rpb24gYWNjb3VudFB1YmxpY0Zyb21QdWJsaWNHZW5lcmF0b3IocHVibGljR2VuQnl0ZXMpIHtcbiAgICBjb25zdCByb290UHViUG9pbnQgPSBzZWNwMjU2azFfMS5zZWNwMjU2azEuUHJvamVjdGl2ZVBvaW50LmZyb21IZXgocHVibGljR2VuQnl0ZXMpO1xuICAgIGNvbnN0IHNjYWxhciA9IGRlcml2ZVNjYWxhcihwdWJsaWNHZW5CeXRlcywgMCk7XG4gICAgY29uc3QgcG9pbnQgPSBzZWNwMjU2azFfMS5zZWNwMjU2azEuUHJvamVjdGl2ZVBvaW50LkJBU0UubXVsdGlwbHkoc2NhbGFyKTtcbiAgICBjb25zdCBvZmZzZXQgPSByb290UHViUG9pbnQuYWRkKHBvaW50KTtcbiAgICByZXR1cm4gb2Zmc2V0LnRvUmF3Qnl0ZXModHJ1ZSk7XG59XG5leHBvcnRzLmFjY291bnRQdWJsaWNGcm9tUHVibGljR2VuZXJhdG9yID0gYWNjb3VudFB1YmxpY0Zyb21QdWJsaWNHZW5lcmF0b3I7XG4vLyMgc291cmNlTWFwcGluZ1VSTD11dGlscy5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/xrpl-secret-numbers/node_modules/ripple-keypairs/dist/signing-schemes/secp256k1/utils.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/xrpl-secret-numbers/node_modules/ripple-keypairs/dist/utils/Sha512.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/xrpl-secret-numbers/node_modules/ripple-keypairs/dist/utils/Sha512.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst sha512_1 = __webpack_require__(/*! @xrplf/isomorphic/sha512 */ \"(ssr)/./node_modules/@xrplf/isomorphic/dist/sha512/index.js\");\nconst utils_1 = __webpack_require__(/*! @noble/curves/abstract/utils */ \"(ssr)/./node_modules/@noble/curves/abstract/utils.js\");\nclass Sha512 {\n    constructor() {\n        // instantiate empty sha512 hash\n        this.hash = sha512_1.sha512.create();\n    }\n    static half(input) {\n        return new Sha512().add(input).first256();\n    }\n    add(bytes) {\n        this.hash.update(bytes);\n        return this;\n    }\n    addU32(i) {\n        const buffer = new Uint8Array(4);\n        new DataView(buffer.buffer).setUint32(0, i);\n        return this.add(buffer);\n    }\n    finish() {\n        return this.hash.digest();\n    }\n    first256() {\n        return this.finish().slice(0, 32);\n    }\n    first256BigInt() {\n        return (0, utils_1.bytesToNumberBE)(this.first256());\n    }\n}\nexports[\"default\"] = Sha512;\n//# sourceMappingURL=Sha512.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMveHJwbC1zZWNyZXQtbnVtYmVycy9ub2RlX21vZHVsZXMvcmlwcGxlLWtleXBhaXJzL2Rpc3QvdXRpbHMvU2hhNTEyLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGlCQUFpQixtQkFBTyxDQUFDLDZGQUEwQjtBQUNuRCxnQkFBZ0IsbUJBQU8sQ0FBQywwRkFBOEI7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWU7QUFDZiIsInNvdXJjZXMiOlsid2VicGFjazovL21pY3JvbGVuZGVyLy4vbm9kZV9tb2R1bGVzL3hycGwtc2VjcmV0LW51bWJlcnMvbm9kZV9tb2R1bGVzL3JpcHBsZS1rZXlwYWlycy9kaXN0L3V0aWxzL1NoYTUxMi5qcz9iODNhIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3Qgc2hhNTEyXzEgPSByZXF1aXJlKFwiQHhycGxmL2lzb21vcnBoaWMvc2hhNTEyXCIpO1xuY29uc3QgdXRpbHNfMSA9IHJlcXVpcmUoXCJAbm9ibGUvY3VydmVzL2Fic3RyYWN0L3V0aWxzXCIpO1xuY2xhc3MgU2hhNTEyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgLy8gaW5zdGFudGlhdGUgZW1wdHkgc2hhNTEyIGhhc2hcbiAgICAgICAgdGhpcy5oYXNoID0gc2hhNTEyXzEuc2hhNTEyLmNyZWF0ZSgpO1xuICAgIH1cbiAgICBzdGF0aWMgaGFsZihpbnB1dCkge1xuICAgICAgICByZXR1cm4gbmV3IFNoYTUxMigpLmFkZChpbnB1dCkuZmlyc3QyNTYoKTtcbiAgICB9XG4gICAgYWRkKGJ5dGVzKSB7XG4gICAgICAgIHRoaXMuaGFzaC51cGRhdGUoYnl0ZXMpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgYWRkVTMyKGkpIHtcbiAgICAgICAgY29uc3QgYnVmZmVyID0gbmV3IFVpbnQ4QXJyYXkoNCk7XG4gICAgICAgIG5ldyBEYXRhVmlldyhidWZmZXIuYnVmZmVyKS5zZXRVaW50MzIoMCwgaSk7XG4gICAgICAgIHJldHVybiB0aGlzLmFkZChidWZmZXIpO1xuICAgIH1cbiAgICBmaW5pc2goKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmhhc2guZGlnZXN0KCk7XG4gICAgfVxuICAgIGZpcnN0MjU2KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5maW5pc2goKS5zbGljZSgwLCAzMik7XG4gICAgfVxuICAgIGZpcnN0MjU2QmlnSW50KCkge1xuICAgICAgICByZXR1cm4gKDAsIHV0aWxzXzEuYnl0ZXNUb051bWJlckJFKSh0aGlzLmZpcnN0MjU2KCkpO1xuICAgIH1cbn1cbmV4cG9ydHMuZGVmYXVsdCA9IFNoYTUxMjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVNoYTUxMi5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/xrpl-secret-numbers/node_modules/ripple-keypairs/dist/utils/Sha512.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/xrpl-secret-numbers/node_modules/ripple-keypairs/dist/utils/assert.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/xrpl-secret-numbers/node_modules/ripple-keypairs/dist/utils/assert.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst assertHelper = {\n    ok(cond, message) {\n        if (!cond) {\n            throw new Error(message);\n        }\n    },\n};\nexports[\"default\"] = assertHelper;\n//# sourceMappingURL=assert.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMveHJwbC1zZWNyZXQtbnVtYmVycy9ub2RlX21vZHVsZXMvcmlwcGxlLWtleXBhaXJzL2Rpc3QvdXRpbHMvYXNzZXJ0LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxrQkFBZTtBQUNmIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbWljcm9sZW5kZXIvLi9ub2RlX21vZHVsZXMveHJwbC1zZWNyZXQtbnVtYmVycy9ub2RlX21vZHVsZXMvcmlwcGxlLWtleXBhaXJzL2Rpc3QvdXRpbHMvYXNzZXJ0LmpzP2VhNzciXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBhc3NlcnRIZWxwZXIgPSB7XG4gICAgb2soY29uZCwgbWVzc2FnZSkge1xuICAgICAgICBpZiAoIWNvbmQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgICAgICAgfVxuICAgIH0sXG59O1xuZXhwb3J0cy5kZWZhdWx0ID0gYXNzZXJ0SGVscGVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YXNzZXJ0LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/xrpl-secret-numbers/node_modules/ripple-keypairs/dist/utils/assert.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/xrpl-secret-numbers/node_modules/ripple-keypairs/dist/utils/getAlgorithmFromKey.js":
/*!*********************************************************************************************************!*\
  !*** ./node_modules/xrpl-secret-numbers/node_modules/ripple-keypairs/dist/utils/getAlgorithmFromKey.js ***!
  \*********************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.getAlgorithmFromPrivateKey = exports.getAlgorithmFromPublicKey = exports.getAlgorithmFromKey = void 0;\nvar Prefix;\n(function (Prefix) {\n    Prefix[Prefix[\"NONE\"] = -1] = \"NONE\";\n    Prefix[Prefix[\"ED25519\"] = 237] = \"ED25519\";\n    Prefix[Prefix[\"SECP256K1_PUB_X\"] = 2] = \"SECP256K1_PUB_X\";\n    Prefix[Prefix[\"SECP256K1_PUB_X_ODD_Y\"] = 3] = \"SECP256K1_PUB_X_ODD_Y\";\n    Prefix[Prefix[\"SECP256K1_PUB_XY\"] = 4] = \"SECP256K1_PUB_XY\";\n    Prefix[Prefix[\"SECP256K1_PRIVATE\"] = 0] = \"SECP256K1_PRIVATE\";\n})(Prefix || (Prefix = {}));\n/**\n * | Curve     | Type        | Prefix | Length | Description                                           | Algorithm       |\n * |-----------|-------------|:------:|:------:|-------------------------------------------------------|----------------:|\n * | ed25519   | Private     |  0xED  |   33   | prefix + Uint256LE (0 < n < order )                   |         ed25519 |\n * | ed25519   | Public      |  0xED  |   33   | prefix + 32 y-bytes                                   |         ed25519 |\n * | secp256k1 | Public (1)  |  0x02  |   33   | prefix + 32 x-bytes                                   | ecdsa-secp256k1 |\n * | secp256k1 | Public (2)  |  0x03  |   33   | prefix + 32 x-bytes (y is odd)                        | ecdsa-secp256k1 |\n * | secp256k1 | Public (3)  |  0x04  |   65   | prefix + 32 x-bytes + 32 y-bytes                      | ecdsa-secp256k1 |\n * | secp256k1 | Private (1) |  None  |   32   | Uint256BE (0 < n < order)                             | ecdsa-secp256k1 |\n * | secp256k1 | Private (2) |  0x00  |   33   | prefix + Uint256BE (0 < n < order)                    | ecdsa-secp256k1 |\n *\n * Note: The 0x00 prefix for secpk256k1 Private (2) essentially 0 pads the number\n *       and the interpreted number is the same as 32 bytes.\n */\nconst KEY_TYPES = {\n    [`private_${Prefix.NONE}_32`]: 'ecdsa-secp256k1',\n    [`private_${Prefix.SECP256K1_PRIVATE}_33`]: 'ecdsa-secp256k1',\n    [`private_${Prefix.ED25519}_33`]: 'ed25519',\n    [`public_${Prefix.ED25519}_33`]: 'ed25519',\n    [`public_${Prefix.SECP256K1_PUB_X}_33`]: 'ecdsa-secp256k1',\n    [`public_${Prefix.SECP256K1_PUB_X_ODD_Y}_33`]: 'ecdsa-secp256k1',\n    [`public_${Prefix.SECP256K1_PUB_XY}_65`]: 'ecdsa-secp256k1',\n};\nfunction getKeyInfo(key) {\n    return {\n        prefix: key.length < 2 ? Prefix.NONE : parseInt(key.slice(0, 2), 16),\n        len: key.length / 2,\n    };\n}\nfunction prefixRepr(prefix) {\n    return prefix === Prefix.NONE\n        ? 'None'\n        : `0x${prefix.toString(16).padStart(2, '0')}`;\n}\nfunction getValidFormatsTable(type) {\n    // No need overkill with renderTable method\n    const padding = 2;\n    const colWidth = {\n        algorithm: 'ecdsa-secp256k1'.length + padding,\n        prefix: '0x00'.length + padding,\n    };\n    return Object.entries(KEY_TYPES)\n        .filter(([key]) => key.startsWith(type))\n        .map(([key, algorithm]) => {\n        const [, prefix, length] = key.split('_');\n        const paddedAlgo = algorithm.padEnd(colWidth.algorithm);\n        const paddedPrefix = prefixRepr(Number(prefix)).padEnd(colWidth.prefix);\n        return `${paddedAlgo} - Prefix: ${paddedPrefix} Length: ${length} bytes`;\n    })\n        .join('\\n');\n}\nfunction keyError({ key, type, prefix, len, }) {\n    const validFormats = getValidFormatsTable(type);\n    return `invalid_key:\n\nType: ${type}\nKey: ${key}\nPrefix: ${prefixRepr(prefix)} \nLength: ${len} bytes\n\nAcceptable ${type} formats are:\n${validFormats}\n`;\n}\n/**\n * Determines the algorithm associated with a given key (public/private).\n *\n * @param key - hexadecimal string representation of the key.\n * @param type - whether expected key is public or private\n * @returns Algorithm algorithm for signing/verifying\n * @throws Error when key is invalid\n */\nfunction getAlgorithmFromKey(key, type) {\n    const { prefix, len } = getKeyInfo(key);\n    // Special case back compat support for no prefix\n    const usedPrefix = type === 'private' && len === 32 ? Prefix.NONE : prefix;\n    const algorithm = KEY_TYPES[`${type}_${usedPrefix}_${len}`];\n    if (!algorithm) {\n        throw new Error(keyError({ key, type, len, prefix: usedPrefix }));\n    }\n    return algorithm;\n}\nexports.getAlgorithmFromKey = getAlgorithmFromKey;\nfunction getAlgorithmFromPublicKey(key) {\n    return getAlgorithmFromKey(key, 'public');\n}\nexports.getAlgorithmFromPublicKey = getAlgorithmFromPublicKey;\nfunction getAlgorithmFromPrivateKey(key) {\n    return getAlgorithmFromKey(key, 'private');\n}\nexports.getAlgorithmFromPrivateKey = getAlgorithmFromPrivateKey;\n//# sourceMappingURL=getAlgorithmFromKey.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMveHJwbC1zZWNyZXQtbnVtYmVycy9ub2RlX21vZHVsZXMvcmlwcGxlLWtleXBhaXJzL2Rpc3QvdXRpbHMvZ2V0QWxnb3JpdGhtRnJvbUtleS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxrQ0FBa0MsR0FBRyxpQ0FBaUMsR0FBRywyQkFBMkI7QUFDcEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsd0JBQXdCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixZQUFZO0FBQzVCLGdCQUFnQix5QkFBeUI7QUFDekMsZ0JBQWdCLGVBQWU7QUFDL0IsZUFBZSxlQUFlO0FBQzlCLGVBQWUsdUJBQXVCO0FBQ3RDLGVBQWUsNkJBQTZCO0FBQzVDLGVBQWUsd0JBQXdCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxxQ0FBcUM7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixZQUFZLFlBQVksY0FBYyxVQUFVLFFBQVE7QUFDMUUsS0FBSztBQUNMO0FBQ0E7QUFDQSxvQkFBb0IseUJBQXlCO0FBQzdDO0FBQ0E7O0FBRUEsUUFBUTtBQUNSLE9BQU87QUFDUCxVQUFVO0FBQ1YsVUFBVSxLQUFLOztBQUVmLGFBQWEsTUFBTTtBQUNuQixFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksY0FBYztBQUMxQjtBQUNBO0FBQ0EsbUNBQW1DLEtBQUssR0FBRyxXQUFXLEdBQUcsSUFBSTtBQUM3RDtBQUNBLG1DQUFtQyxvQ0FBb0M7QUFDdkU7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9taWNyb2xlbmRlci8uL25vZGVfbW9kdWxlcy94cnBsLXNlY3JldC1udW1iZXJzL25vZGVfbW9kdWxlcy9yaXBwbGUta2V5cGFpcnMvZGlzdC91dGlscy9nZXRBbGdvcml0aG1Gcm9tS2V5LmpzPzZmOTQiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmdldEFsZ29yaXRobUZyb21Qcml2YXRlS2V5ID0gZXhwb3J0cy5nZXRBbGdvcml0aG1Gcm9tUHVibGljS2V5ID0gZXhwb3J0cy5nZXRBbGdvcml0aG1Gcm9tS2V5ID0gdm9pZCAwO1xudmFyIFByZWZpeDtcbihmdW5jdGlvbiAoUHJlZml4KSB7XG4gICAgUHJlZml4W1ByZWZpeFtcIk5PTkVcIl0gPSAtMV0gPSBcIk5PTkVcIjtcbiAgICBQcmVmaXhbUHJlZml4W1wiRUQyNTUxOVwiXSA9IDIzN10gPSBcIkVEMjU1MTlcIjtcbiAgICBQcmVmaXhbUHJlZml4W1wiU0VDUDI1NksxX1BVQl9YXCJdID0gMl0gPSBcIlNFQ1AyNTZLMV9QVUJfWFwiO1xuICAgIFByZWZpeFtQcmVmaXhbXCJTRUNQMjU2SzFfUFVCX1hfT0REX1lcIl0gPSAzXSA9IFwiU0VDUDI1NksxX1BVQl9YX09ERF9ZXCI7XG4gICAgUHJlZml4W1ByZWZpeFtcIlNFQ1AyNTZLMV9QVUJfWFlcIl0gPSA0XSA9IFwiU0VDUDI1NksxX1BVQl9YWVwiO1xuICAgIFByZWZpeFtQcmVmaXhbXCJTRUNQMjU2SzFfUFJJVkFURVwiXSA9IDBdID0gXCJTRUNQMjU2SzFfUFJJVkFURVwiO1xufSkoUHJlZml4IHx8IChQcmVmaXggPSB7fSkpO1xuLyoqXG4gKiB8IEN1cnZlICAgICB8IFR5cGUgICAgICAgIHwgUHJlZml4IHwgTGVuZ3RoIHwgRGVzY3JpcHRpb24gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBBbGdvcml0aG0gICAgICAgfFxuICogfC0tLS0tLS0tLS0tfC0tLS0tLS0tLS0tLS18Oi0tLS0tLTp8Oi0tLS0tLTp8LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLXwtLS0tLS0tLS0tLS0tLS0tOnxcbiAqIHwgZWQyNTUxOSAgIHwgUHJpdmF0ZSAgICAgfCAgMHhFRCAgfCAgIDMzICAgfCBwcmVmaXggKyBVaW50MjU2TEUgKDAgPCBuIDwgb3JkZXIgKSAgICAgICAgICAgICAgICAgICB8ICAgICAgICAgZWQyNTUxOSB8XG4gKiB8IGVkMjU1MTkgICB8IFB1YmxpYyAgICAgIHwgIDB4RUQgIHwgICAzMyAgIHwgcHJlZml4ICsgMzIgeS1ieXRlcyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgICAgIGVkMjU1MTkgfFxuICogfCBzZWNwMjU2azEgfCBQdWJsaWMgKDEpICB8ICAweDAyICB8ICAgMzMgICB8IHByZWZpeCArIDMyIHgtYnl0ZXMgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgZWNkc2Etc2VjcDI1NmsxIHxcbiAqIHwgc2VjcDI1NmsxIHwgUHVibGljICgyKSAgfCAgMHgwMyAgfCAgIDMzICAgfCBwcmVmaXggKyAzMiB4LWJ5dGVzICh5IGlzIG9kZCkgICAgICAgICAgICAgICAgICAgICAgICB8IGVjZHNhLXNlY3AyNTZrMSB8XG4gKiB8IHNlY3AyNTZrMSB8IFB1YmxpYyAoMykgIHwgIDB4MDQgIHwgICA2NSAgIHwgcHJlZml4ICsgMzIgeC1ieXRlcyArIDMyIHktYnl0ZXMgICAgICAgICAgICAgICAgICAgICAgfCBlY2RzYS1zZWNwMjU2azEgfFxuICogfCBzZWNwMjU2azEgfCBQcml2YXRlICgxKSB8ICBOb25lICB8ICAgMzIgICB8IFVpbnQyNTZCRSAoMCA8IG4gPCBvcmRlcikgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgZWNkc2Etc2VjcDI1NmsxIHxcbiAqIHwgc2VjcDI1NmsxIHwgUHJpdmF0ZSAoMikgfCAgMHgwMCAgfCAgIDMzICAgfCBwcmVmaXggKyBVaW50MjU2QkUgKDAgPCBuIDwgb3JkZXIpICAgICAgICAgICAgICAgICAgICB8IGVjZHNhLXNlY3AyNTZrMSB8XG4gKlxuICogTm90ZTogVGhlIDB4MDAgcHJlZml4IGZvciBzZWNwazI1NmsxIFByaXZhdGUgKDIpIGVzc2VudGlhbGx5IDAgcGFkcyB0aGUgbnVtYmVyXG4gKiAgICAgICBhbmQgdGhlIGludGVycHJldGVkIG51bWJlciBpcyB0aGUgc2FtZSBhcyAzMiBieXRlcy5cbiAqL1xuY29uc3QgS0VZX1RZUEVTID0ge1xuICAgIFtgcHJpdmF0ZV8ke1ByZWZpeC5OT05FfV8zMmBdOiAnZWNkc2Etc2VjcDI1NmsxJyxcbiAgICBbYHByaXZhdGVfJHtQcmVmaXguU0VDUDI1NksxX1BSSVZBVEV9XzMzYF06ICdlY2RzYS1zZWNwMjU2azEnLFxuICAgIFtgcHJpdmF0ZV8ke1ByZWZpeC5FRDI1NTE5fV8zM2BdOiAnZWQyNTUxOScsXG4gICAgW2BwdWJsaWNfJHtQcmVmaXguRUQyNTUxOX1fMzNgXTogJ2VkMjU1MTknLFxuICAgIFtgcHVibGljXyR7UHJlZml4LlNFQ1AyNTZLMV9QVUJfWH1fMzNgXTogJ2VjZHNhLXNlY3AyNTZrMScsXG4gICAgW2BwdWJsaWNfJHtQcmVmaXguU0VDUDI1NksxX1BVQl9YX09ERF9ZfV8zM2BdOiAnZWNkc2Etc2VjcDI1NmsxJyxcbiAgICBbYHB1YmxpY18ke1ByZWZpeC5TRUNQMjU2SzFfUFVCX1hZfV82NWBdOiAnZWNkc2Etc2VjcDI1NmsxJyxcbn07XG5mdW5jdGlvbiBnZXRLZXlJbmZvKGtleSkge1xuICAgIHJldHVybiB7XG4gICAgICAgIHByZWZpeDoga2V5Lmxlbmd0aCA8IDIgPyBQcmVmaXguTk9ORSA6IHBhcnNlSW50KGtleS5zbGljZSgwLCAyKSwgMTYpLFxuICAgICAgICBsZW46IGtleS5sZW5ndGggLyAyLFxuICAgIH07XG59XG5mdW5jdGlvbiBwcmVmaXhSZXByKHByZWZpeCkge1xuICAgIHJldHVybiBwcmVmaXggPT09IFByZWZpeC5OT05FXG4gICAgICAgID8gJ05vbmUnXG4gICAgICAgIDogYDB4JHtwcmVmaXgudG9TdHJpbmcoMTYpLnBhZFN0YXJ0KDIsICcwJyl9YDtcbn1cbmZ1bmN0aW9uIGdldFZhbGlkRm9ybWF0c1RhYmxlKHR5cGUpIHtcbiAgICAvLyBObyBuZWVkIG92ZXJraWxsIHdpdGggcmVuZGVyVGFibGUgbWV0aG9kXG4gICAgY29uc3QgcGFkZGluZyA9IDI7XG4gICAgY29uc3QgY29sV2lkdGggPSB7XG4gICAgICAgIGFsZ29yaXRobTogJ2VjZHNhLXNlY3AyNTZrMScubGVuZ3RoICsgcGFkZGluZyxcbiAgICAgICAgcHJlZml4OiAnMHgwMCcubGVuZ3RoICsgcGFkZGluZyxcbiAgICB9O1xuICAgIHJldHVybiBPYmplY3QuZW50cmllcyhLRVlfVFlQRVMpXG4gICAgICAgIC5maWx0ZXIoKFtrZXldKSA9PiBrZXkuc3RhcnRzV2l0aCh0eXBlKSlcbiAgICAgICAgLm1hcCgoW2tleSwgYWxnb3JpdGhtXSkgPT4ge1xuICAgICAgICBjb25zdCBbLCBwcmVmaXgsIGxlbmd0aF0gPSBrZXkuc3BsaXQoJ18nKTtcbiAgICAgICAgY29uc3QgcGFkZGVkQWxnbyA9IGFsZ29yaXRobS5wYWRFbmQoY29sV2lkdGguYWxnb3JpdGhtKTtcbiAgICAgICAgY29uc3QgcGFkZGVkUHJlZml4ID0gcHJlZml4UmVwcihOdW1iZXIocHJlZml4KSkucGFkRW5kKGNvbFdpZHRoLnByZWZpeCk7XG4gICAgICAgIHJldHVybiBgJHtwYWRkZWRBbGdvfSAtIFByZWZpeDogJHtwYWRkZWRQcmVmaXh9IExlbmd0aDogJHtsZW5ndGh9IGJ5dGVzYDtcbiAgICB9KVxuICAgICAgICAuam9pbignXFxuJyk7XG59XG5mdW5jdGlvbiBrZXlFcnJvcih7IGtleSwgdHlwZSwgcHJlZml4LCBsZW4sIH0pIHtcbiAgICBjb25zdCB2YWxpZEZvcm1hdHMgPSBnZXRWYWxpZEZvcm1hdHNUYWJsZSh0eXBlKTtcbiAgICByZXR1cm4gYGludmFsaWRfa2V5OlxuXG5UeXBlOiAke3R5cGV9XG5LZXk6ICR7a2V5fVxuUHJlZml4OiAke3ByZWZpeFJlcHIocHJlZml4KX0gXG5MZW5ndGg6ICR7bGVufSBieXRlc1xuXG5BY2NlcHRhYmxlICR7dHlwZX0gZm9ybWF0cyBhcmU6XG4ke3ZhbGlkRm9ybWF0c31cbmA7XG59XG4vKipcbiAqIERldGVybWluZXMgdGhlIGFsZ29yaXRobSBhc3NvY2lhdGVkIHdpdGggYSBnaXZlbiBrZXkgKHB1YmxpYy9wcml2YXRlKS5cbiAqXG4gKiBAcGFyYW0ga2V5IC0gaGV4YWRlY2ltYWwgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBrZXkuXG4gKiBAcGFyYW0gdHlwZSAtIHdoZXRoZXIgZXhwZWN0ZWQga2V5IGlzIHB1YmxpYyBvciBwcml2YXRlXG4gKiBAcmV0dXJucyBBbGdvcml0aG0gYWxnb3JpdGhtIGZvciBzaWduaW5nL3ZlcmlmeWluZ1xuICogQHRocm93cyBFcnJvciB3aGVuIGtleSBpcyBpbnZhbGlkXG4gKi9cbmZ1bmN0aW9uIGdldEFsZ29yaXRobUZyb21LZXkoa2V5LCB0eXBlKSB7XG4gICAgY29uc3QgeyBwcmVmaXgsIGxlbiB9ID0gZ2V0S2V5SW5mbyhrZXkpO1xuICAgIC8vIFNwZWNpYWwgY2FzZSBiYWNrIGNvbXBhdCBzdXBwb3J0IGZvciBubyBwcmVmaXhcbiAgICBjb25zdCB1c2VkUHJlZml4ID0gdHlwZSA9PT0gJ3ByaXZhdGUnICYmIGxlbiA9PT0gMzIgPyBQcmVmaXguTk9ORSA6IHByZWZpeDtcbiAgICBjb25zdCBhbGdvcml0aG0gPSBLRVlfVFlQRVNbYCR7dHlwZX1fJHt1c2VkUHJlZml4fV8ke2xlbn1gXTtcbiAgICBpZiAoIWFsZ29yaXRobSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3Ioa2V5RXJyb3IoeyBrZXksIHR5cGUsIGxlbiwgcHJlZml4OiB1c2VkUHJlZml4IH0pKTtcbiAgICB9XG4gICAgcmV0dXJuIGFsZ29yaXRobTtcbn1cbmV4cG9ydHMuZ2V0QWxnb3JpdGhtRnJvbUtleSA9IGdldEFsZ29yaXRobUZyb21LZXk7XG5mdW5jdGlvbiBnZXRBbGdvcml0aG1Gcm9tUHVibGljS2V5KGtleSkge1xuICAgIHJldHVybiBnZXRBbGdvcml0aG1Gcm9tS2V5KGtleSwgJ3B1YmxpYycpO1xufVxuZXhwb3J0cy5nZXRBbGdvcml0aG1Gcm9tUHVibGljS2V5ID0gZ2V0QWxnb3JpdGhtRnJvbVB1YmxpY0tleTtcbmZ1bmN0aW9uIGdldEFsZ29yaXRobUZyb21Qcml2YXRlS2V5KGtleSkge1xuICAgIHJldHVybiBnZXRBbGdvcml0aG1Gcm9tS2V5KGtleSwgJ3ByaXZhdGUnKTtcbn1cbmV4cG9ydHMuZ2V0QWxnb3JpdGhtRnJvbVByaXZhdGVLZXkgPSBnZXRBbGdvcml0aG1Gcm9tUHJpdmF0ZUtleTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWdldEFsZ29yaXRobUZyb21LZXkuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/xrpl-secret-numbers/node_modules/ripple-keypairs/dist/utils/getAlgorithmFromKey.js\n");

/***/ })

};
;