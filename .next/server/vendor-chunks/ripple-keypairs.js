"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/ripple-keypairs";
exports.ids = ["vendor-chunks/ripple-keypairs"];
exports.modules = {

/***/ "(ssr)/./node_modules/ripple-keypairs/dist/Sha512.js":
/*!*****************************************************!*\
  !*** ./node_modules/ripple-keypairs/dist/Sha512.js ***!
  \*****************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n/* eslint-disable no-bitwise --\n * lots of bitwise operators necessary for this */\nconst hashjs = __importStar(__webpack_require__(/*! hash.js */ \"(ssr)/./node_modules/hash.js/lib/hash.js\"));\nconst BigNum = __webpack_require__(/*! bn.js */ \"(ssr)/./node_modules/bn.js/lib/bn.js\");\nclass Sha512 {\n    constructor() {\n        this.hash = hashjs.sha512();\n    }\n    add(bytes) {\n        this.hash.update(bytes);\n        return this;\n    }\n    addU32(i) {\n        return this.add([\n            (i >>> 24) & 0xff,\n            (i >>> 16) & 0xff,\n            (i >>> 8) & 0xff,\n            i & 0xff,\n        ]);\n    }\n    finish() {\n        return this.hash.digest();\n    }\n    first256() {\n        return this.finish().slice(0, 32);\n    }\n    first256BN() {\n        return new BigNum(this.first256());\n    }\n}\nexports[\"default\"] = Sha512;\n//# sourceMappingURL=Sha512.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmlwcGxlLWtleXBhaXJzL2Rpc3QvU2hhNTEyLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG9DQUFvQztBQUNuRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSwwQ0FBMEMsNEJBQTRCO0FBQ3RFLENBQUM7QUFDRDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RDtBQUNBO0FBQ0EsNEJBQTRCLG1CQUFPLENBQUMseURBQVM7QUFDN0MsZUFBZSxtQkFBTyxDQUFDLG1EQUFPO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBZTtBQUNmIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbWljcm9sZW5kZXIvLi9ub2RlX21vZHVsZXMvcmlwcGxlLWtleXBhaXJzL2Rpc3QvU2hhNTEyLmpzP2JjMTMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobSwgayk7XG4gICAgaWYgKCFkZXNjIHx8IChcImdldFwiIGluIGRlc2MgPyAhbS5fX2VzTW9kdWxlIDogZGVzYy53cml0YWJsZSB8fCBkZXNjLmNvbmZpZ3VyYWJsZSkpIHtcbiAgICAgIGRlc2MgPSB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH07XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgZGVzYyk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fc2V0TW9kdWxlRGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19zZXRNb2R1bGVEZWZhdWx0KSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCB2KSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIFwiZGVmYXVsdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2IH0pO1xufSkgOiBmdW5jdGlvbihvLCB2KSB7XG4gICAgb1tcImRlZmF1bHRcIl0gPSB2O1xufSk7XG52YXIgX19pbXBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydFN0YXIpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoayAhPT0gXCJkZWZhdWx0XCIgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIF9fY3JlYXRlQmluZGluZyhyZXN1bHQsIG1vZCwgayk7XG4gICAgX19zZXRNb2R1bGVEZWZhdWx0KHJlc3VsdCwgbW9kKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8qIGVzbGludC1kaXNhYmxlIG5vLWJpdHdpc2UgLS1cbiAqIGxvdHMgb2YgYml0d2lzZSBvcGVyYXRvcnMgbmVjZXNzYXJ5IGZvciB0aGlzICovXG5jb25zdCBoYXNoanMgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcImhhc2guanNcIikpO1xuY29uc3QgQmlnTnVtID0gcmVxdWlyZShcImJuLmpzXCIpO1xuY2xhc3MgU2hhNTEyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5oYXNoID0gaGFzaGpzLnNoYTUxMigpO1xuICAgIH1cbiAgICBhZGQoYnl0ZXMpIHtcbiAgICAgICAgdGhpcy5oYXNoLnVwZGF0ZShieXRlcyk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBhZGRVMzIoaSkge1xuICAgICAgICByZXR1cm4gdGhpcy5hZGQoW1xuICAgICAgICAgICAgKGkgPj4+IDI0KSAmIDB4ZmYsXG4gICAgICAgICAgICAoaSA+Pj4gMTYpICYgMHhmZixcbiAgICAgICAgICAgIChpID4+PiA4KSAmIDB4ZmYsXG4gICAgICAgICAgICBpICYgMHhmZixcbiAgICAgICAgXSk7XG4gICAgfVxuICAgIGZpbmlzaCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaGFzaC5kaWdlc3QoKTtcbiAgICB9XG4gICAgZmlyc3QyNTYoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZpbmlzaCgpLnNsaWNlKDAsIDMyKTtcbiAgICB9XG4gICAgZmlyc3QyNTZCTigpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBCaWdOdW0odGhpcy5maXJzdDI1NigpKTtcbiAgICB9XG59XG5leHBvcnRzLmRlZmF1bHQgPSBTaGE1MTI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1TaGE1MTIuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ripple-keypairs/dist/Sha512.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ripple-keypairs/dist/index.js":
/*!****************************************************!*\
  !*** ./node_modules/ripple-keypairs/dist/index.js ***!
  \****************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.decodeSeed = exports.deriveNodeAddress = exports.deriveAddress = exports.verify = exports.sign = exports.deriveKeypair = exports.generateSeed = void 0;\nconst assert = __importStar(__webpack_require__(/*! assert */ \"assert\"));\nconst brorand = __webpack_require__(/*! brorand */ \"(ssr)/./node_modules/brorand/index.js\");\nconst hashjs = __importStar(__webpack_require__(/*! hash.js */ \"(ssr)/./node_modules/hash.js/lib/hash.js\"));\nconst elliptic = __importStar(__webpack_require__(/*! elliptic */ \"(ssr)/./node_modules/elliptic/lib/elliptic.js\"));\nconst addressCodec = __importStar(__webpack_require__(/*! ripple-address-codec */ \"(ssr)/./node_modules/ripple-address-codec/dist/index.js\"));\nconst secp256k1_1 = __webpack_require__(/*! ./secp256k1 */ \"(ssr)/./node_modules/ripple-keypairs/dist/secp256k1.js\");\nconst utils = __importStar(__webpack_require__(/*! ./utils */ \"(ssr)/./node_modules/ripple-keypairs/dist/utils.js\"));\nconst Ed25519 = elliptic.eddsa('ed25519');\nconst Secp256k1 = elliptic.ec('secp256k1');\nconst { hexToBytes } = utils;\nconst { bytesToHex } = utils;\nfunction generateSeed(options = {}) {\n    assert.ok(!options.entropy || options.entropy.length >= 16, 'entropy too short');\n    const entropy = options.entropy ? options.entropy.slice(0, 16) : brorand(16);\n    const type = options.algorithm === 'ed25519' ? 'ed25519' : 'secp256k1';\n    return addressCodec.encodeSeed(Buffer.from(entropy), type);\n}\nexports.generateSeed = generateSeed;\nfunction hash(message) {\n    return hashjs.sha512().update(message).digest().slice(0, 32);\n}\nconst secp256k1 = {\n    deriveKeypair(entropy, options) {\n        const prefix = '00';\n        const privateKey = prefix + (0, secp256k1_1.derivePrivateKey)(entropy, options).toString(16, 64).toUpperCase();\n        const publicKey = bytesToHex(Secp256k1.keyFromPrivate(privateKey.slice(2))\n            .getPublic()\n            .encodeCompressed());\n        return { privateKey, publicKey };\n    },\n    sign(message, privateKey) {\n        return bytesToHex(Secp256k1.sign(hash(message), hexToBytes(privateKey), {\n            canonical: true,\n        }).toDER());\n    },\n    verify(message, signature, publicKey) {\n        return Secp256k1.verify(hash(message), signature, hexToBytes(publicKey));\n    },\n};\nconst ed25519 = {\n    deriveKeypair(entropy) {\n        const prefix = 'ED';\n        const rawPrivateKey = hash(entropy);\n        const privateKey = prefix + bytesToHex(rawPrivateKey);\n        const publicKey = prefix + bytesToHex(Ed25519.keyFromSecret(rawPrivateKey).pubBytes());\n        return { privateKey, publicKey };\n    },\n    sign(message, privateKey) {\n        // caution: Ed25519.sign interprets all strings as hex, stripping\n        // any non-hex characters without warning\n        assert.ok(Array.isArray(message), 'message must be array of octets');\n        return bytesToHex(Ed25519.sign(message, hexToBytes(privateKey).slice(1)).toBytes());\n    },\n    verify(message, signature, publicKey) {\n        return Ed25519.verify(message, hexToBytes(signature), hexToBytes(publicKey).slice(1));\n    },\n};\nfunction select(algorithm) {\n    const methods = { 'ecdsa-secp256k1': secp256k1, ed25519 };\n    return methods[algorithm];\n}\nfunction deriveKeypair(seed, options) {\n    const decoded = addressCodec.decodeSeed(seed);\n    const algorithm = decoded.type === 'ed25519' ? 'ed25519' : 'ecdsa-secp256k1';\n    const method = select(algorithm);\n    const keypair = method.deriveKeypair(decoded.bytes, options);\n    const messageToVerify = hash('This test message should verify.');\n    const signature = method.sign(messageToVerify, keypair.privateKey);\n    /* istanbul ignore if */\n    if (method.verify(messageToVerify, signature, keypair.publicKey) !== true) {\n        throw new Error('derived keypair did not generate verifiable signature');\n    }\n    return keypair;\n}\nexports.deriveKeypair = deriveKeypair;\nfunction getAlgorithmFromKey(key) {\n    const bytes = hexToBytes(key);\n    return bytes.length === 33 && bytes[0] === 0xed\n        ? 'ed25519'\n        : 'ecdsa-secp256k1';\n}\nfunction sign(messageHex, privateKey) {\n    const algorithm = getAlgorithmFromKey(privateKey);\n    return select(algorithm).sign(hexToBytes(messageHex), privateKey);\n}\nexports.sign = sign;\nfunction verify(messageHex, signature, publicKey) {\n    const algorithm = getAlgorithmFromKey(publicKey);\n    return select(algorithm).verify(hexToBytes(messageHex), signature, publicKey);\n}\nexports.verify = verify;\nfunction deriveAddressFromBytes(publicKeyBytes) {\n    return addressCodec.encodeAccountID(utils.computePublicKeyHash(publicKeyBytes));\n}\nfunction deriveAddress(publicKey) {\n    return deriveAddressFromBytes(Buffer.from(hexToBytes(publicKey)));\n}\nexports.deriveAddress = deriveAddress;\nfunction deriveNodeAddress(publicKey) {\n    const generatorBytes = addressCodec.decodeNodePublic(publicKey);\n    const accountPublicBytes = (0, secp256k1_1.accountPublicFromPublicGenerator)(generatorBytes);\n    return deriveAddressFromBytes(accountPublicBytes);\n}\nexports.deriveNodeAddress = deriveNodeAddress;\nconst { decodeSeed } = addressCodec;\nexports.decodeSeed = decodeSeed;\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmlwcGxlLWtleXBhaXJzL2Rpc3QvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsb0NBQW9DO0FBQ25EO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLDBDQUEwQyw0QkFBNEI7QUFDdEUsQ0FBQztBQUNEO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGtCQUFrQixHQUFHLHlCQUF5QixHQUFHLHFCQUFxQixHQUFHLGNBQWMsR0FBRyxZQUFZLEdBQUcscUJBQXFCLEdBQUcsb0JBQW9CO0FBQ3JKLDRCQUE0QixtQkFBTyxDQUFDLHNCQUFRO0FBQzVDLGdCQUFnQixtQkFBTyxDQUFDLHNEQUFTO0FBQ2pDLDRCQUE0QixtQkFBTyxDQUFDLHlEQUFTO0FBQzdDLDhCQUE4QixtQkFBTyxDQUFDLCtEQUFVO0FBQ2hELGtDQUFrQyxtQkFBTyxDQUFDLHFGQUFzQjtBQUNoRSxvQkFBb0IsbUJBQU8sQ0FBQywyRUFBYTtBQUN6QywyQkFBMkIsbUJBQU8sQ0FBQyxtRUFBUztBQUM1QztBQUNBO0FBQ0EsUUFBUSxhQUFhO0FBQ3JCLFFBQVEsYUFBYTtBQUNyQixrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekIsUUFBUSxhQUFhO0FBQ3JCLGtCQUFrQjtBQUNsQiIsInNvdXJjZXMiOlsid2VicGFjazovL21pY3JvbGVuZGVyLy4vbm9kZV9tb2R1bGVzL3JpcHBsZS1rZXlwYWlycy9kaXN0L2luZGV4LmpzPzMyNjciXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobSwgayk7XG4gICAgaWYgKCFkZXNjIHx8IChcImdldFwiIGluIGRlc2MgPyAhbS5fX2VzTW9kdWxlIDogZGVzYy53cml0YWJsZSB8fCBkZXNjLmNvbmZpZ3VyYWJsZSkpIHtcbiAgICAgIGRlc2MgPSB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH07XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgZGVzYyk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fc2V0TW9kdWxlRGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19zZXRNb2R1bGVEZWZhdWx0KSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCB2KSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIFwiZGVmYXVsdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2IH0pO1xufSkgOiBmdW5jdGlvbihvLCB2KSB7XG4gICAgb1tcImRlZmF1bHRcIl0gPSB2O1xufSk7XG52YXIgX19pbXBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydFN0YXIpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoayAhPT0gXCJkZWZhdWx0XCIgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIF9fY3JlYXRlQmluZGluZyhyZXN1bHQsIG1vZCwgayk7XG4gICAgX19zZXRNb2R1bGVEZWZhdWx0KHJlc3VsdCwgbW9kKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZGVjb2RlU2VlZCA9IGV4cG9ydHMuZGVyaXZlTm9kZUFkZHJlc3MgPSBleHBvcnRzLmRlcml2ZUFkZHJlc3MgPSBleHBvcnRzLnZlcmlmeSA9IGV4cG9ydHMuc2lnbiA9IGV4cG9ydHMuZGVyaXZlS2V5cGFpciA9IGV4cG9ydHMuZ2VuZXJhdGVTZWVkID0gdm9pZCAwO1xuY29uc3QgYXNzZXJ0ID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCJhc3NlcnRcIikpO1xuY29uc3QgYnJvcmFuZCA9IHJlcXVpcmUoXCJicm9yYW5kXCIpO1xuY29uc3QgaGFzaGpzID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCJoYXNoLmpzXCIpKTtcbmNvbnN0IGVsbGlwdGljID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCJlbGxpcHRpY1wiKSk7XG5jb25zdCBhZGRyZXNzQ29kZWMgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcInJpcHBsZS1hZGRyZXNzLWNvZGVjXCIpKTtcbmNvbnN0IHNlY3AyNTZrMV8xID0gcmVxdWlyZShcIi4vc2VjcDI1NmsxXCIpO1xuY29uc3QgdXRpbHMgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIi4vdXRpbHNcIikpO1xuY29uc3QgRWQyNTUxOSA9IGVsbGlwdGljLmVkZHNhKCdlZDI1NTE5Jyk7XG5jb25zdCBTZWNwMjU2azEgPSBlbGxpcHRpYy5lYygnc2VjcDI1NmsxJyk7XG5jb25zdCB7IGhleFRvQnl0ZXMgfSA9IHV0aWxzO1xuY29uc3QgeyBieXRlc1RvSGV4IH0gPSB1dGlscztcbmZ1bmN0aW9uIGdlbmVyYXRlU2VlZChvcHRpb25zID0ge30pIHtcbiAgICBhc3NlcnQub2soIW9wdGlvbnMuZW50cm9weSB8fCBvcHRpb25zLmVudHJvcHkubGVuZ3RoID49IDE2LCAnZW50cm9weSB0b28gc2hvcnQnKTtcbiAgICBjb25zdCBlbnRyb3B5ID0gb3B0aW9ucy5lbnRyb3B5ID8gb3B0aW9ucy5lbnRyb3B5LnNsaWNlKDAsIDE2KSA6IGJyb3JhbmQoMTYpO1xuICAgIGNvbnN0IHR5cGUgPSBvcHRpb25zLmFsZ29yaXRobSA9PT0gJ2VkMjU1MTknID8gJ2VkMjU1MTknIDogJ3NlY3AyNTZrMSc7XG4gICAgcmV0dXJuIGFkZHJlc3NDb2RlYy5lbmNvZGVTZWVkKEJ1ZmZlci5mcm9tKGVudHJvcHkpLCB0eXBlKTtcbn1cbmV4cG9ydHMuZ2VuZXJhdGVTZWVkID0gZ2VuZXJhdGVTZWVkO1xuZnVuY3Rpb24gaGFzaChtZXNzYWdlKSB7XG4gICAgcmV0dXJuIGhhc2hqcy5zaGE1MTIoKS51cGRhdGUobWVzc2FnZSkuZGlnZXN0KCkuc2xpY2UoMCwgMzIpO1xufVxuY29uc3Qgc2VjcDI1NmsxID0ge1xuICAgIGRlcml2ZUtleXBhaXIoZW50cm9weSwgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBwcmVmaXggPSAnMDAnO1xuICAgICAgICBjb25zdCBwcml2YXRlS2V5ID0gcHJlZml4ICsgKDAsIHNlY3AyNTZrMV8xLmRlcml2ZVByaXZhdGVLZXkpKGVudHJvcHksIG9wdGlvbnMpLnRvU3RyaW5nKDE2LCA2NCkudG9VcHBlckNhc2UoKTtcbiAgICAgICAgY29uc3QgcHVibGljS2V5ID0gYnl0ZXNUb0hleChTZWNwMjU2azEua2V5RnJvbVByaXZhdGUocHJpdmF0ZUtleS5zbGljZSgyKSlcbiAgICAgICAgICAgIC5nZXRQdWJsaWMoKVxuICAgICAgICAgICAgLmVuY29kZUNvbXByZXNzZWQoKSk7XG4gICAgICAgIHJldHVybiB7IHByaXZhdGVLZXksIHB1YmxpY0tleSB9O1xuICAgIH0sXG4gICAgc2lnbihtZXNzYWdlLCBwcml2YXRlS2V5KSB7XG4gICAgICAgIHJldHVybiBieXRlc1RvSGV4KFNlY3AyNTZrMS5zaWduKGhhc2gobWVzc2FnZSksIGhleFRvQnl0ZXMocHJpdmF0ZUtleSksIHtcbiAgICAgICAgICAgIGNhbm9uaWNhbDogdHJ1ZSxcbiAgICAgICAgfSkudG9ERVIoKSk7XG4gICAgfSxcbiAgICB2ZXJpZnkobWVzc2FnZSwgc2lnbmF0dXJlLCBwdWJsaWNLZXkpIHtcbiAgICAgICAgcmV0dXJuIFNlY3AyNTZrMS52ZXJpZnkoaGFzaChtZXNzYWdlKSwgc2lnbmF0dXJlLCBoZXhUb0J5dGVzKHB1YmxpY0tleSkpO1xuICAgIH0sXG59O1xuY29uc3QgZWQyNTUxOSA9IHtcbiAgICBkZXJpdmVLZXlwYWlyKGVudHJvcHkpIHtcbiAgICAgICAgY29uc3QgcHJlZml4ID0gJ0VEJztcbiAgICAgICAgY29uc3QgcmF3UHJpdmF0ZUtleSA9IGhhc2goZW50cm9weSk7XG4gICAgICAgIGNvbnN0IHByaXZhdGVLZXkgPSBwcmVmaXggKyBieXRlc1RvSGV4KHJhd1ByaXZhdGVLZXkpO1xuICAgICAgICBjb25zdCBwdWJsaWNLZXkgPSBwcmVmaXggKyBieXRlc1RvSGV4KEVkMjU1MTkua2V5RnJvbVNlY3JldChyYXdQcml2YXRlS2V5KS5wdWJCeXRlcygpKTtcbiAgICAgICAgcmV0dXJuIHsgcHJpdmF0ZUtleSwgcHVibGljS2V5IH07XG4gICAgfSxcbiAgICBzaWduKG1lc3NhZ2UsIHByaXZhdGVLZXkpIHtcbiAgICAgICAgLy8gY2F1dGlvbjogRWQyNTUxOS5zaWduIGludGVycHJldHMgYWxsIHN0cmluZ3MgYXMgaGV4LCBzdHJpcHBpbmdcbiAgICAgICAgLy8gYW55IG5vbi1oZXggY2hhcmFjdGVycyB3aXRob3V0IHdhcm5pbmdcbiAgICAgICAgYXNzZXJ0Lm9rKEFycmF5LmlzQXJyYXkobWVzc2FnZSksICdtZXNzYWdlIG11c3QgYmUgYXJyYXkgb2Ygb2N0ZXRzJyk7XG4gICAgICAgIHJldHVybiBieXRlc1RvSGV4KEVkMjU1MTkuc2lnbihtZXNzYWdlLCBoZXhUb0J5dGVzKHByaXZhdGVLZXkpLnNsaWNlKDEpKS50b0J5dGVzKCkpO1xuICAgIH0sXG4gICAgdmVyaWZ5KG1lc3NhZ2UsIHNpZ25hdHVyZSwgcHVibGljS2V5KSB7XG4gICAgICAgIHJldHVybiBFZDI1NTE5LnZlcmlmeShtZXNzYWdlLCBoZXhUb0J5dGVzKHNpZ25hdHVyZSksIGhleFRvQnl0ZXMocHVibGljS2V5KS5zbGljZSgxKSk7XG4gICAgfSxcbn07XG5mdW5jdGlvbiBzZWxlY3QoYWxnb3JpdGhtKSB7XG4gICAgY29uc3QgbWV0aG9kcyA9IHsgJ2VjZHNhLXNlY3AyNTZrMSc6IHNlY3AyNTZrMSwgZWQyNTUxOSB9O1xuICAgIHJldHVybiBtZXRob2RzW2FsZ29yaXRobV07XG59XG5mdW5jdGlvbiBkZXJpdmVLZXlwYWlyKHNlZWQsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBkZWNvZGVkID0gYWRkcmVzc0NvZGVjLmRlY29kZVNlZWQoc2VlZCk7XG4gICAgY29uc3QgYWxnb3JpdGhtID0gZGVjb2RlZC50eXBlID09PSAnZWQyNTUxOScgPyAnZWQyNTUxOScgOiAnZWNkc2Etc2VjcDI1NmsxJztcbiAgICBjb25zdCBtZXRob2QgPSBzZWxlY3QoYWxnb3JpdGhtKTtcbiAgICBjb25zdCBrZXlwYWlyID0gbWV0aG9kLmRlcml2ZUtleXBhaXIoZGVjb2RlZC5ieXRlcywgb3B0aW9ucyk7XG4gICAgY29uc3QgbWVzc2FnZVRvVmVyaWZ5ID0gaGFzaCgnVGhpcyB0ZXN0IG1lc3NhZ2Ugc2hvdWxkIHZlcmlmeS4nKTtcbiAgICBjb25zdCBzaWduYXR1cmUgPSBtZXRob2Quc2lnbihtZXNzYWdlVG9WZXJpZnksIGtleXBhaXIucHJpdmF0ZUtleSk7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKG1ldGhvZC52ZXJpZnkobWVzc2FnZVRvVmVyaWZ5LCBzaWduYXR1cmUsIGtleXBhaXIucHVibGljS2V5KSAhPT0gdHJ1ZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Rlcml2ZWQga2V5cGFpciBkaWQgbm90IGdlbmVyYXRlIHZlcmlmaWFibGUgc2lnbmF0dXJlJyk7XG4gICAgfVxuICAgIHJldHVybiBrZXlwYWlyO1xufVxuZXhwb3J0cy5kZXJpdmVLZXlwYWlyID0gZGVyaXZlS2V5cGFpcjtcbmZ1bmN0aW9uIGdldEFsZ29yaXRobUZyb21LZXkoa2V5KSB7XG4gICAgY29uc3QgYnl0ZXMgPSBoZXhUb0J5dGVzKGtleSk7XG4gICAgcmV0dXJuIGJ5dGVzLmxlbmd0aCA9PT0gMzMgJiYgYnl0ZXNbMF0gPT09IDB4ZWRcbiAgICAgICAgPyAnZWQyNTUxOSdcbiAgICAgICAgOiAnZWNkc2Etc2VjcDI1NmsxJztcbn1cbmZ1bmN0aW9uIHNpZ24obWVzc2FnZUhleCwgcHJpdmF0ZUtleSkge1xuICAgIGNvbnN0IGFsZ29yaXRobSA9IGdldEFsZ29yaXRobUZyb21LZXkocHJpdmF0ZUtleSk7XG4gICAgcmV0dXJuIHNlbGVjdChhbGdvcml0aG0pLnNpZ24oaGV4VG9CeXRlcyhtZXNzYWdlSGV4KSwgcHJpdmF0ZUtleSk7XG59XG5leHBvcnRzLnNpZ24gPSBzaWduO1xuZnVuY3Rpb24gdmVyaWZ5KG1lc3NhZ2VIZXgsIHNpZ25hdHVyZSwgcHVibGljS2V5KSB7XG4gICAgY29uc3QgYWxnb3JpdGhtID0gZ2V0QWxnb3JpdGhtRnJvbUtleShwdWJsaWNLZXkpO1xuICAgIHJldHVybiBzZWxlY3QoYWxnb3JpdGhtKS52ZXJpZnkoaGV4VG9CeXRlcyhtZXNzYWdlSGV4KSwgc2lnbmF0dXJlLCBwdWJsaWNLZXkpO1xufVxuZXhwb3J0cy52ZXJpZnkgPSB2ZXJpZnk7XG5mdW5jdGlvbiBkZXJpdmVBZGRyZXNzRnJvbUJ5dGVzKHB1YmxpY0tleUJ5dGVzKSB7XG4gICAgcmV0dXJuIGFkZHJlc3NDb2RlYy5lbmNvZGVBY2NvdW50SUQodXRpbHMuY29tcHV0ZVB1YmxpY0tleUhhc2gocHVibGljS2V5Qnl0ZXMpKTtcbn1cbmZ1bmN0aW9uIGRlcml2ZUFkZHJlc3MocHVibGljS2V5KSB7XG4gICAgcmV0dXJuIGRlcml2ZUFkZHJlc3NGcm9tQnl0ZXMoQnVmZmVyLmZyb20oaGV4VG9CeXRlcyhwdWJsaWNLZXkpKSk7XG59XG5leHBvcnRzLmRlcml2ZUFkZHJlc3MgPSBkZXJpdmVBZGRyZXNzO1xuZnVuY3Rpb24gZGVyaXZlTm9kZUFkZHJlc3MocHVibGljS2V5KSB7XG4gICAgY29uc3QgZ2VuZXJhdG9yQnl0ZXMgPSBhZGRyZXNzQ29kZWMuZGVjb2RlTm9kZVB1YmxpYyhwdWJsaWNLZXkpO1xuICAgIGNvbnN0IGFjY291bnRQdWJsaWNCeXRlcyA9ICgwLCBzZWNwMjU2azFfMS5hY2NvdW50UHVibGljRnJvbVB1YmxpY0dlbmVyYXRvcikoZ2VuZXJhdG9yQnl0ZXMpO1xuICAgIHJldHVybiBkZXJpdmVBZGRyZXNzRnJvbUJ5dGVzKGFjY291bnRQdWJsaWNCeXRlcyk7XG59XG5leHBvcnRzLmRlcml2ZU5vZGVBZGRyZXNzID0gZGVyaXZlTm9kZUFkZHJlc3M7XG5jb25zdCB7IGRlY29kZVNlZWQgfSA9IGFkZHJlc3NDb2RlYztcbmV4cG9ydHMuZGVjb2RlU2VlZCA9IGRlY29kZVNlZWQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ripple-keypairs/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ripple-keypairs/dist/secp256k1.js":
/*!********************************************************!*\
  !*** ./node_modules/ripple-keypairs/dist/secp256k1.js ***!
  \********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.accountPublicFromPublicGenerator = exports.derivePrivateKey = void 0;\nconst elliptic = __importStar(__webpack_require__(/*! elliptic */ \"(ssr)/./node_modules/elliptic/lib/elliptic.js\"));\nconst Sha512_1 = __importDefault(__webpack_require__(/*! ./Sha512 */ \"(ssr)/./node_modules/ripple-keypairs/dist/Sha512.js\"));\nconst secp256k1 = elliptic.ec('secp256k1');\nfunction deriveScalar(bytes, discrim) {\n    const order = secp256k1.curve.n;\n    for (let i = 0; i <= 0xffffffff; i++) {\n        // We hash the bytes to find a 256 bit number, looping until we are sure it\n        // is less than the order of the curve.\n        const hasher = new Sha512_1.default().add(bytes);\n        // If the optional discriminator index was passed in, update the hash.\n        if (discrim !== undefined) {\n            hasher.addU32(discrim);\n        }\n        hasher.addU32(i);\n        const key = hasher.first256BN();\n        /* istanbul ignore else */\n        if (key.cmpn(0) > 0 && key.cmp(order) < 0) {\n            return key;\n        }\n    }\n    // This error is practically impossible to reach.\n    // The order of the curve describes the (finite) amount of points on the curve\n    // https://github.com/indutny/elliptic/blob/master/lib/elliptic/curves.js#L182\n    // How often will an (essentially) random number generated by Sha512 be larger than that?\n    // There's 2^32 chances (the for loop) to get a number smaller than the order,\n    // and it's rare that you'll even get past the first loop iteration.\n    // Note that in TypeScript we actually need the throw, otherwise the function signature would be BN | undefined\n    //\n    /* istanbul ignore next */\n    throw new Error('impossible unicorn ;)');\n}\n/**\n * @param seed - Bytes.\n * @param [opts] - Object.\n * @param [opts.accountIndex=0] - The account number to generate.\n * @param [opts.validator=false] - Generate root key-pair,\n *                                              as used by validators.\n * @returns {bn.js} 256 bit scalar value.\n *\n */\nfunction derivePrivateKey(seed, opts = {}) {\n    const root = opts.validator;\n    const order = secp256k1.curve.n;\n    // This private generator represents the `root` private key, and is what's\n    // used by validators for signing when a keypair is generated from a seed.\n    const privateGen = deriveScalar(seed);\n    if (root) {\n        // As returned by validation_create for a given seed\n        return privateGen;\n    }\n    const publicGen = secp256k1.g.mul(privateGen);\n    // A seed can generate many keypairs as a function of the seed and a uint32.\n    // Almost everyone just uses the first account, `0`.\n    const accountIndex = opts.accountIndex || 0;\n    return deriveScalar(publicGen.encodeCompressed(), accountIndex)\n        .add(privateGen)\n        .mod(order);\n}\nexports.derivePrivateKey = derivePrivateKey;\nfunction accountPublicFromPublicGenerator(publicGenBytes) {\n    const rootPubPoint = secp256k1.curve.decodePoint(publicGenBytes);\n    const scalar = deriveScalar(publicGenBytes, 0);\n    const point = secp256k1.g.mul(scalar);\n    const offset = rootPubPoint.add(point);\n    return offset.encodeCompressed();\n}\nexports.accountPublicFromPublicGenerator = accountPublicFromPublicGenerator;\n//# sourceMappingURL=secp256k1.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmlwcGxlLWtleXBhaXJzL2Rpc3Qvc2VjcDI1NmsxLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG9DQUFvQztBQUNuRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSwwQ0FBMEMsNEJBQTRCO0FBQ3RFLENBQUM7QUFDRDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHdDQUF3QyxHQUFHLHdCQUF3QjtBQUNuRSw4QkFBOEIsbUJBQU8sQ0FBQywrREFBVTtBQUNoRCxpQ0FBaUMsbUJBQU8sQ0FBQyxxRUFBVTtBQUNuRDtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsaUJBQWlCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDO0FBQ3hDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbWljcm9sZW5kZXIvLi9ub2RlX21vZHVsZXMvcmlwcGxlLWtleXBhaXJzL2Rpc3Qvc2VjcDI1NmsxLmpzP2MyZmIiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobSwgayk7XG4gICAgaWYgKCFkZXNjIHx8IChcImdldFwiIGluIGRlc2MgPyAhbS5fX2VzTW9kdWxlIDogZGVzYy53cml0YWJsZSB8fCBkZXNjLmNvbmZpZ3VyYWJsZSkpIHtcbiAgICAgIGRlc2MgPSB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH07XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgZGVzYyk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fc2V0TW9kdWxlRGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19zZXRNb2R1bGVEZWZhdWx0KSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCB2KSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIFwiZGVmYXVsdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2IH0pO1xufSkgOiBmdW5jdGlvbihvLCB2KSB7XG4gICAgb1tcImRlZmF1bHRcIl0gPSB2O1xufSk7XG52YXIgX19pbXBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydFN0YXIpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoayAhPT0gXCJkZWZhdWx0XCIgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIF9fY3JlYXRlQmluZGluZyhyZXN1bHQsIG1vZCwgayk7XG4gICAgX19zZXRNb2R1bGVEZWZhdWx0KHJlc3VsdCwgbW9kKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuYWNjb3VudFB1YmxpY0Zyb21QdWJsaWNHZW5lcmF0b3IgPSBleHBvcnRzLmRlcml2ZVByaXZhdGVLZXkgPSB2b2lkIDA7XG5jb25zdCBlbGxpcHRpYyA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwiZWxsaXB0aWNcIikpO1xuY29uc3QgU2hhNTEyXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vU2hhNTEyXCIpKTtcbmNvbnN0IHNlY3AyNTZrMSA9IGVsbGlwdGljLmVjKCdzZWNwMjU2azEnKTtcbmZ1bmN0aW9uIGRlcml2ZVNjYWxhcihieXRlcywgZGlzY3JpbSkge1xuICAgIGNvbnN0IG9yZGVyID0gc2VjcDI1NmsxLmN1cnZlLm47XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPD0gMHhmZmZmZmZmZjsgaSsrKSB7XG4gICAgICAgIC8vIFdlIGhhc2ggdGhlIGJ5dGVzIHRvIGZpbmQgYSAyNTYgYml0IG51bWJlciwgbG9vcGluZyB1bnRpbCB3ZSBhcmUgc3VyZSBpdFxuICAgICAgICAvLyBpcyBsZXNzIHRoYW4gdGhlIG9yZGVyIG9mIHRoZSBjdXJ2ZS5cbiAgICAgICAgY29uc3QgaGFzaGVyID0gbmV3IFNoYTUxMl8xLmRlZmF1bHQoKS5hZGQoYnl0ZXMpO1xuICAgICAgICAvLyBJZiB0aGUgb3B0aW9uYWwgZGlzY3JpbWluYXRvciBpbmRleCB3YXMgcGFzc2VkIGluLCB1cGRhdGUgdGhlIGhhc2guXG4gICAgICAgIGlmIChkaXNjcmltICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGhhc2hlci5hZGRVMzIoZGlzY3JpbSk7XG4gICAgICAgIH1cbiAgICAgICAgaGFzaGVyLmFkZFUzMihpKTtcbiAgICAgICAgY29uc3Qga2V5ID0gaGFzaGVyLmZpcnN0MjU2Qk4oKTtcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICAgICAgaWYgKGtleS5jbXBuKDApID4gMCAmJiBrZXkuY21wKG9yZGVyKSA8IDApIHtcbiAgICAgICAgICAgIHJldHVybiBrZXk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gVGhpcyBlcnJvciBpcyBwcmFjdGljYWxseSBpbXBvc3NpYmxlIHRvIHJlYWNoLlxuICAgIC8vIFRoZSBvcmRlciBvZiB0aGUgY3VydmUgZGVzY3JpYmVzIHRoZSAoZmluaXRlKSBhbW91bnQgb2YgcG9pbnRzIG9uIHRoZSBjdXJ2ZVxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9pbmR1dG55L2VsbGlwdGljL2Jsb2IvbWFzdGVyL2xpYi9lbGxpcHRpYy9jdXJ2ZXMuanMjTDE4MlxuICAgIC8vIEhvdyBvZnRlbiB3aWxsIGFuIChlc3NlbnRpYWxseSkgcmFuZG9tIG51bWJlciBnZW5lcmF0ZWQgYnkgU2hhNTEyIGJlIGxhcmdlciB0aGFuIHRoYXQ/XG4gICAgLy8gVGhlcmUncyAyXjMyIGNoYW5jZXMgKHRoZSBmb3IgbG9vcCkgdG8gZ2V0IGEgbnVtYmVyIHNtYWxsZXIgdGhhbiB0aGUgb3JkZXIsXG4gICAgLy8gYW5kIGl0J3MgcmFyZSB0aGF0IHlvdSdsbCBldmVuIGdldCBwYXN0IHRoZSBmaXJzdCBsb29wIGl0ZXJhdGlvbi5cbiAgICAvLyBOb3RlIHRoYXQgaW4gVHlwZVNjcmlwdCB3ZSBhY3R1YWxseSBuZWVkIHRoZSB0aHJvdywgb3RoZXJ3aXNlIHRoZSBmdW5jdGlvbiBzaWduYXR1cmUgd291bGQgYmUgQk4gfCB1bmRlZmluZWRcbiAgICAvL1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgdGhyb3cgbmV3IEVycm9yKCdpbXBvc3NpYmxlIHVuaWNvcm4gOyknKTtcbn1cbi8qKlxuICogQHBhcmFtIHNlZWQgLSBCeXRlcy5cbiAqIEBwYXJhbSBbb3B0c10gLSBPYmplY3QuXG4gKiBAcGFyYW0gW29wdHMuYWNjb3VudEluZGV4PTBdIC0gVGhlIGFjY291bnQgbnVtYmVyIHRvIGdlbmVyYXRlLlxuICogQHBhcmFtIFtvcHRzLnZhbGlkYXRvcj1mYWxzZV0gLSBHZW5lcmF0ZSByb290IGtleS1wYWlyLFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXMgdXNlZCBieSB2YWxpZGF0b3JzLlxuICogQHJldHVybnMge2JuLmpzfSAyNTYgYml0IHNjYWxhciB2YWx1ZS5cbiAqXG4gKi9cbmZ1bmN0aW9uIGRlcml2ZVByaXZhdGVLZXkoc2VlZCwgb3B0cyA9IHt9KSB7XG4gICAgY29uc3Qgcm9vdCA9IG9wdHMudmFsaWRhdG9yO1xuICAgIGNvbnN0IG9yZGVyID0gc2VjcDI1NmsxLmN1cnZlLm47XG4gICAgLy8gVGhpcyBwcml2YXRlIGdlbmVyYXRvciByZXByZXNlbnRzIHRoZSBgcm9vdGAgcHJpdmF0ZSBrZXksIGFuZCBpcyB3aGF0J3NcbiAgICAvLyB1c2VkIGJ5IHZhbGlkYXRvcnMgZm9yIHNpZ25pbmcgd2hlbiBhIGtleXBhaXIgaXMgZ2VuZXJhdGVkIGZyb20gYSBzZWVkLlxuICAgIGNvbnN0IHByaXZhdGVHZW4gPSBkZXJpdmVTY2FsYXIoc2VlZCk7XG4gICAgaWYgKHJvb3QpIHtcbiAgICAgICAgLy8gQXMgcmV0dXJuZWQgYnkgdmFsaWRhdGlvbl9jcmVhdGUgZm9yIGEgZ2l2ZW4gc2VlZFxuICAgICAgICByZXR1cm4gcHJpdmF0ZUdlbjtcbiAgICB9XG4gICAgY29uc3QgcHVibGljR2VuID0gc2VjcDI1NmsxLmcubXVsKHByaXZhdGVHZW4pO1xuICAgIC8vIEEgc2VlZCBjYW4gZ2VuZXJhdGUgbWFueSBrZXlwYWlycyBhcyBhIGZ1bmN0aW9uIG9mIHRoZSBzZWVkIGFuZCBhIHVpbnQzMi5cbiAgICAvLyBBbG1vc3QgZXZlcnlvbmUganVzdCB1c2VzIHRoZSBmaXJzdCBhY2NvdW50LCBgMGAuXG4gICAgY29uc3QgYWNjb3VudEluZGV4ID0gb3B0cy5hY2NvdW50SW5kZXggfHwgMDtcbiAgICByZXR1cm4gZGVyaXZlU2NhbGFyKHB1YmxpY0dlbi5lbmNvZGVDb21wcmVzc2VkKCksIGFjY291bnRJbmRleClcbiAgICAgICAgLmFkZChwcml2YXRlR2VuKVxuICAgICAgICAubW9kKG9yZGVyKTtcbn1cbmV4cG9ydHMuZGVyaXZlUHJpdmF0ZUtleSA9IGRlcml2ZVByaXZhdGVLZXk7XG5mdW5jdGlvbiBhY2NvdW50UHVibGljRnJvbVB1YmxpY0dlbmVyYXRvcihwdWJsaWNHZW5CeXRlcykge1xuICAgIGNvbnN0IHJvb3RQdWJQb2ludCA9IHNlY3AyNTZrMS5jdXJ2ZS5kZWNvZGVQb2ludChwdWJsaWNHZW5CeXRlcyk7XG4gICAgY29uc3Qgc2NhbGFyID0gZGVyaXZlU2NhbGFyKHB1YmxpY0dlbkJ5dGVzLCAwKTtcbiAgICBjb25zdCBwb2ludCA9IHNlY3AyNTZrMS5nLm11bChzY2FsYXIpO1xuICAgIGNvbnN0IG9mZnNldCA9IHJvb3RQdWJQb2ludC5hZGQocG9pbnQpO1xuICAgIHJldHVybiBvZmZzZXQuZW5jb2RlQ29tcHJlc3NlZCgpO1xufVxuZXhwb3J0cy5hY2NvdW50UHVibGljRnJvbVB1YmxpY0dlbmVyYXRvciA9IGFjY291bnRQdWJsaWNGcm9tUHVibGljR2VuZXJhdG9yO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2VjcDI1NmsxLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ripple-keypairs/dist/secp256k1.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ripple-keypairs/dist/utils.js":
/*!****************************************************!*\
  !*** ./node_modules/ripple-keypairs/dist/utils.js ***!
  \****************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.computePublicKeyHash = exports.hexToBytes = exports.bytesToHex = void 0;\nconst assert = __importStar(__webpack_require__(/*! assert */ \"assert\"));\nconst hashjs = __importStar(__webpack_require__(/*! hash.js */ \"(ssr)/./node_modules/hash.js/lib/hash.js\"));\nconst BN = __webpack_require__(/*! bn.js */ \"(ssr)/./node_modules/bn.js/lib/bn.js\");\nfunction bytesToHex(a) {\n    return Array.from(a, (byteValue) => {\n        const hex = byteValue.toString(16).toUpperCase();\n        return hex.length > 1 ? hex : `0${hex}`;\n    }).join('');\n}\nexports.bytesToHex = bytesToHex;\nfunction hexToBytes(a) {\n    assert.ok(a.length % 2 === 0);\n    // Special-case length zero to return [].\n    // BN.toArray intentionally returns [0] rather than [] for length zero,\n    // which may make sense for BigNum data, but not for byte strings.\n    return a.length === 0 ? [] : new BN(a, 16).toArray(null, a.length / 2);\n}\nexports.hexToBytes = hexToBytes;\nfunction computePublicKeyHash(publicKeyBytes) {\n    const hash256 = hashjs.sha256().update(publicKeyBytes).digest();\n    const hash160 = hashjs.ripemd160().update(hash256).digest();\n    return Buffer.from(hash160);\n}\nexports.computePublicKeyHash = computePublicKeyHash;\n//# sourceMappingURL=utils.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmlwcGxlLWtleXBhaXJzL2Rpc3QvdXRpbHMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsb0NBQW9DO0FBQ25EO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLDBDQUEwQyw0QkFBNEI7QUFDdEUsQ0FBQztBQUNEO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELDRCQUE0QixHQUFHLGtCQUFrQixHQUFHLGtCQUFrQjtBQUN0RSw0QkFBNEIsbUJBQU8sQ0FBQyxzQkFBUTtBQUM1Qyw0QkFBNEIsbUJBQU8sQ0FBQyx5REFBUztBQUM3QyxXQUFXLG1CQUFPLENBQUMsbURBQU87QUFDMUI7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLElBQUk7QUFDOUMsS0FBSztBQUNMO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9taWNyb2xlbmRlci8uL25vZGVfbW9kdWxlcy9yaXBwbGUta2V5cGFpcnMvZGlzdC91dGlscy5qcz9kOGIyIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG0sIGspO1xuICAgIGlmICghZGVzYyB8fCAoXCJnZXRcIiBpbiBkZXNjID8gIW0uX19lc01vZHVsZSA6IGRlc2Mud3JpdGFibGUgfHwgZGVzYy5jb25maWd1cmFibGUpKSB7XG4gICAgICBkZXNjID0geyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9O1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIGRlc2MpO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX3NldE1vZHVsZURlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9fc2V0TW9kdWxlRGVmYXVsdCkgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgdikge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBcImRlZmF1bHRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdiB9KTtcbn0pIDogZnVuY3Rpb24obywgdikge1xuICAgIG9bXCJkZWZhdWx0XCJdID0gdjtcbn0pO1xudmFyIF9faW1wb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnRTdGFyKSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkgaWYgKGsgIT09IFwiZGVmYXVsdFwiICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSBfX2NyZWF0ZUJpbmRpbmcocmVzdWx0LCBtb2QsIGspO1xuICAgIF9fc2V0TW9kdWxlRGVmYXVsdChyZXN1bHQsIG1vZCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmNvbXB1dGVQdWJsaWNLZXlIYXNoID0gZXhwb3J0cy5oZXhUb0J5dGVzID0gZXhwb3J0cy5ieXRlc1RvSGV4ID0gdm9pZCAwO1xuY29uc3QgYXNzZXJ0ID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCJhc3NlcnRcIikpO1xuY29uc3QgaGFzaGpzID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCJoYXNoLmpzXCIpKTtcbmNvbnN0IEJOID0gcmVxdWlyZShcImJuLmpzXCIpO1xuZnVuY3Rpb24gYnl0ZXNUb0hleChhKSB7XG4gICAgcmV0dXJuIEFycmF5LmZyb20oYSwgKGJ5dGVWYWx1ZSkgPT4ge1xuICAgICAgICBjb25zdCBoZXggPSBieXRlVmFsdWUudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgIHJldHVybiBoZXgubGVuZ3RoID4gMSA/IGhleCA6IGAwJHtoZXh9YDtcbiAgICB9KS5qb2luKCcnKTtcbn1cbmV4cG9ydHMuYnl0ZXNUb0hleCA9IGJ5dGVzVG9IZXg7XG5mdW5jdGlvbiBoZXhUb0J5dGVzKGEpIHtcbiAgICBhc3NlcnQub2soYS5sZW5ndGggJSAyID09PSAwKTtcbiAgICAvLyBTcGVjaWFsLWNhc2UgbGVuZ3RoIHplcm8gdG8gcmV0dXJuIFtdLlxuICAgIC8vIEJOLnRvQXJyYXkgaW50ZW50aW9uYWxseSByZXR1cm5zIFswXSByYXRoZXIgdGhhbiBbXSBmb3IgbGVuZ3RoIHplcm8sXG4gICAgLy8gd2hpY2ggbWF5IG1ha2Ugc2Vuc2UgZm9yIEJpZ051bSBkYXRhLCBidXQgbm90IGZvciBieXRlIHN0cmluZ3MuXG4gICAgcmV0dXJuIGEubGVuZ3RoID09PSAwID8gW10gOiBuZXcgQk4oYSwgMTYpLnRvQXJyYXkobnVsbCwgYS5sZW5ndGggLyAyKTtcbn1cbmV4cG9ydHMuaGV4VG9CeXRlcyA9IGhleFRvQnl0ZXM7XG5mdW5jdGlvbiBjb21wdXRlUHVibGljS2V5SGFzaChwdWJsaWNLZXlCeXRlcykge1xuICAgIGNvbnN0IGhhc2gyNTYgPSBoYXNoanMuc2hhMjU2KCkudXBkYXRlKHB1YmxpY0tleUJ5dGVzKS5kaWdlc3QoKTtcbiAgICBjb25zdCBoYXNoMTYwID0gaGFzaGpzLnJpcGVtZDE2MCgpLnVwZGF0ZShoYXNoMjU2KS5kaWdlc3QoKTtcbiAgICByZXR1cm4gQnVmZmVyLmZyb20oaGFzaDE2MCk7XG59XG5leHBvcnRzLmNvbXB1dGVQdWJsaWNLZXlIYXNoID0gY29tcHV0ZVB1YmxpY0tleUhhc2g7XG4vLyMgc291cmNlTWFwcGluZ1VSTD11dGlscy5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ripple-keypairs/dist/utils.js\n");

/***/ })

};
;