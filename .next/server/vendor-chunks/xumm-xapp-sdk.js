"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/xumm-xapp-sdk";
exports.ids = ["vendor-chunks/xumm-xapp-sdk"];
exports.modules = {

/***/ "(ssr)/./node_modules/xumm-xapp-sdk/dist/index.js":
/*!**************************************************!*\
  !*** ./node_modules/xumm-xapp-sdk/dist/index.js ***!
  \**************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar _a;\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.xApp = void 0;\nconst events_1 = __webpack_require__(/*! events */ \"events\");\nconst types_1 = __webpack_require__(/*! ./types */ \"(ssr)/./node_modules/xumm-xapp-sdk/dist/types.js\");\n__exportStar(__webpack_require__(/*! ./types */ \"(ssr)/./node_modules/xumm-xapp-sdk/dist/types.js\"), exports);\n// localStorage.debug = \"xapp*\";\nconst docMinAliveSec = 0.25;\nconst attemptMs = 250;\nconst attemptDuration = 2000;\nconst appStart = Number(new Date());\nlet documentIsReady;\nconst documentReadyPromise = new Promise((resolve) => {\n    documentIsReady = (value) => {\n        console.log(\"Doc Ready...\");\n        const timeSinceDocLoad = (Number(new Date()) - appStart) / 1000;\n        if (timeSinceDocLoad < docMinAliveSec /* Seconds */) {\n            // Stall\n            console.log(\"Doc not alive >= \" +\n                docMinAliveSec +\n                \" sec, stalling for \" +\n                (docMinAliveSec - timeSinceDocLoad));\n            setTimeout(function () {\n                resolve(value);\n            }, (docMinAliveSec - timeSinceDocLoad) * 1000);\n        }\n        else {\n            // Go ahead\n            console.log(\"Doc alive \" + docMinAliveSec + \"+ sec, go ahead\");\n            resolve(value);\n        }\n    };\n});\ndocumentReadyPromise\n    .then(() => {\n    console.log(\"documentReadyPromise resolved\");\n})\n    .catch((e) => {\n    console.log(e);\n});\nif (typeof document !== \"undefined\") {\n    document.addEventListener(\"readystatechange\", (event) => {\n        console.log(\"(readystatechange: [ \" + document.readyState + \" ])\");\n        if (document.readyState === \"complete\") {\n            documentIsReady();\n        }\n    });\n}\nif (typeof window !== \"undefined\") {\n    console.log(\"Loading xApp SDK\");\n}\nlet _window = (typeof window !== \"undefined\" ? window : {});\nlet isSandbox = false;\nif (_window === null || _window === void 0 ? void 0 : _window.parent) {\n    // XAPP PROXY\n    (_a = _window.parent) === null || _a === void 0 ? void 0 : _a.postMessage(\"XAPP_PROXY_INIT\", \"*\");\n}\nconst xAppActionAttempt = (command, options, attempt = 0) => __awaiter(void 0, void 0, void 0, function* () {\n    var _b, _c;\n    yield documentReadyPromise;\n    if (typeof (_window === null || _window === void 0 ? void 0 : _window.ReactNativeWebView) !== \"undefined\" || isSandbox) {\n        const timeSinceDocLoad = (Number(new Date()) - appStart) / 1000;\n        if ([\"close\"].indexOf(command) > -1) {\n            // Close command awaits app nav state, min sec. alive 4\n            const minAliveTimeSec = 4;\n            if (timeSinceDocLoad < minAliveTimeSec) {\n                console.log(\"xApp close, doc alive < minAliveTimeSec, stall: \" +\n                    (minAliveTimeSec - timeSinceDocLoad));\n                yield new Promise((resolve) => {\n                    setTimeout(() => {\n                        resolve(true);\n                    }, (minAliveTimeSec - timeSinceDocLoad) * 1000);\n                });\n            }\n        }\n        const msgToPost = JSON.stringify(Object.assign({ command }, (options || {})));\n        if (isSandbox) {\n            (_b = _window.parent) === null || _b === void 0 ? void 0 : _b.postMessage(msgToPost, \"*\");\n        }\n        else {\n            (_c = _window.ReactNativeWebView) === null || _c === void 0 ? void 0 : _c.postMessage(msgToPost);\n        }\n        console.log(\"xAppActionAttempt Success\", command, options);\n        return true;\n    }\n    else {\n        if (attempt * attemptMs < attemptDuration) {\n            // Another attempt\n            console.log(\"xAppActionAttempt Attempt \" + attempt + \" Â» Retry\", command, options);\n            yield new Promise((resolve) => {\n                setTimeout(resolve, attemptMs);\n            });\n            return xAppActionAttempt(command, options, attempt + 1);\n        }\n        else {\n            // Nope\n            console.log(\"xAppActionAttempt Failed after attempt \" + attempt, command, options);\n            return new Error(\"xApp.\" +\n                command.replace(/^xApp/, \"\") +\n                \": could not contact Xumm App Host\");\n        }\n    }\n});\nclass xAppThread extends events_1.EventEmitter {\n    constructor() {\n        super();\n        if (document.readyState === \"complete\") {\n            documentIsReady();\n        }\n        const eventHandler = (event) => {\n            const rEvent = event;\n            if (typeof (rEvent === null || rEvent === void 0 ? void 0 : rEvent.data) === \"string\" &&\n                rEvent.data === \"XAPP_PROXY_INIT_ACK\") {\n                console.log(\"xApp Proxy ACK received, switching to PROXY (SANDBOX) mode\");\n                isSandbox = true;\n                return;\n            }\n            try {\n                const _event = JSON.parse((rEvent === null || rEvent === void 0 ? void 0 : rEvent.data) || \"{}\");\n                console.log(\"_event (typeof, {_event}) \", typeof _event, { _event });\n                if (typeof _event === \"object\" && _event !== null) {\n                    if (typeof _event.method === \"string\" &&\n                        _event.method in types_1.xAppEvents) {\n                        console.log(\"xApp Event received\", _event.method, _event);\n                        const method = _event.method;\n                        delete _event.method;\n                        switch (method) {\n                            case String(types_1.xAppEvents.payloadResolved):\n                                this.emit(\"payload\", _event);\n                                break;\n                            case String(types_1.xAppEvents.scanQr):\n                                this.emit(\"qr\", _event);\n                                break;\n                            case String(types_1.xAppEvents.networkSwitch):\n                                this.emit(\"networkswitch\", _event);\n                                break;\n                            case String(types_1.xAppEvents.selectDestination):\n                                this.emit(\"destination\", _event);\n                                break;\n                        }\n                    }\n                    else {\n                        console.log(\"xApp Event received, not in xAppEvents:\", _event.method);\n                    }\n                }\n            }\n            catch (e) {\n                const emessage = (e === null || e === void 0 ? void 0 : e.message) || \"\";\n                if (!emessage.match(/XAPP_PROXY_INIT/)) {\n                    console.log(\"xApp Event received, cannot parse as JSON\", emessage);\n                }\n            }\n        };\n        if (typeof window.addEventListener === \"function\") {\n            window.addEventListener(\"message\", eventHandler);\n        }\n        if (typeof document.addEventListener === \"function\") {\n            document.addEventListener(\"message\", eventHandler);\n        }\n    }\n    getEnvironment() {\n        const t = thread();\n        if (!t) {\n            return { version: \"\", ott: \"\" };\n        }\n        return t.getEnvironment();\n    }\n    navigate(navigateOptions) {\n        if (typeof (navigateOptions === null || navigateOptions === void 0 ? void 0 : navigateOptions.xApp) !== \"string\") {\n            return Promise.reject(new Error(\"xApp.navigate: Invalid argument: `xApp`\"));\n        }\n        return xAppActionAttempt(\"xAppNavigate\", navigateOptions);\n    }\n    openSignRequest(openSignRequestOptions) {\n        if (typeof (openSignRequestOptions === null || openSignRequestOptions === void 0 ? void 0 : openSignRequestOptions.uuid) !== \"string\") {\n            return Promise.reject(new Error(\"xApp.openSignRequest: Invalid argument: `uuid`\"));\n        }\n        if (!openSignRequestOptions.uuid.match(/^[0-9A-F]{8}-[0-9A-F]{4}-4[0-9A-F]{3}-[89AB][0-9A-F]{3}-[0-9A-F]{12}$/i)) {\n            return Promise.reject(new Error(\"xApp.openSignRequest: Invalid payload UUID\"));\n        }\n        return xAppActionAttempt(\"openSignRequest\", openSignRequestOptions);\n    }\n    selectDestination(selectDestinationOptions) {\n        return xAppActionAttempt(\"selectDestination\", selectDestinationOptions);\n    }\n    openBrowser(openBrowserOptions) {\n        if (typeof (openBrowserOptions === null || openBrowserOptions === void 0 ? void 0 : openBrowserOptions.url) !== \"string\") {\n            return Promise.reject(new Error(\"xApp.openBrowser: Invalid argument: `url`\"));\n        }\n        return xAppActionAttempt(\"openBrowser\", openBrowserOptions);\n    }\n    share(shareOptions) {\n        if (typeof (shareOptions === null || shareOptions === void 0 ? void 0 : shareOptions.text) !== \"string\") {\n            return Promise.reject(new Error(\"xApp.share: Invalid argument: `text`\"));\n        }\n        return xAppActionAttempt(\"share\", shareOptions);\n    }\n    scanQr() {\n        return xAppActionAttempt(\"scanQr\");\n    }\n    tx(txOptions) {\n        if (typeof (txOptions === null || txOptions === void 0 ? void 0 : txOptions.tx) !== \"string\") {\n            return Promise.reject(new Error(\"xApp.tx: Invalid argument: `tx`\"));\n        }\n        if (typeof (txOptions === null || txOptions === void 0 ? void 0 : txOptions.account) !== \"string\") {\n            return Promise.reject(new Error(\"xApp.tx: Invalid argument: `account`\"));\n        }\n        return xAppActionAttempt(\"txDetails\", txOptions);\n    }\n    close(closeOptions) {\n        return xAppActionAttempt(\"close\", closeOptions);\n    }\n    ready() {\n        return xAppActionAttempt(\"ready\");\n    }\n    customCommand(customCommand, customCommandOptions) {\n        return xAppActionAttempt(customCommand, customCommandOptions);\n    }\n}\nconst thread = (_xApp) => {\n    let attached = false;\n    if (_xApp) {\n        if (typeof _window === \"object\") {\n            if (typeof _window._xAppSdk === \"undefined\") {\n                _window._xAppSdk = _xApp;\n                attached = true;\n            }\n        }\n    }\n    const instance = _window === null || _window === void 0 ? void 0 : _window._xAppSdk;\n    if (instance && attached) {\n        console.log(\"xAppSdk attached to window\");\n    }\n    return instance;\n};\nclass xApp {\n    constructor() {\n        this.xummEnvironment = {\n            version: \"\",\n            ott: \"\",\n        };\n        if (typeof window === \"undefined\" || typeof document === \"undefined\") {\n            return;\n        }\n        if (typeof navigator !== \"undefined\") {\n            if (typeof (navigator === null || navigator === void 0 ? void 0 : navigator.userAgent) === \"string\") {\n                const uaMatch = navigator.userAgent\n                    .trim()\n                    .match(/xumm\\/xapp:([0-9]{1,}\\.[0-9]{1,}\\.[0-9]{1,}).*ott:([0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12})/);\n                if (uaMatch) {\n                    this.xummEnvironment.version = uaMatch[1];\n                    this.xummEnvironment.ott = uaMatch[2];\n                }\n            }\n        }\n        if (this.xummEnvironment.version === \"\") {\n            console.log(\"Warning: Xumm Version could not be retrieved from User Agent, possibly not loaded in xApp context?\");\n        }\n        if (!thread()) {\n            thread(new xAppThread());\n        }\n    }\n    getEnvironment() {\n        return this.xummEnvironment;\n    }\n    on(event, listener) {\n        const t = thread();\n        if (!t) {\n            return;\n        }\n        t.on(event, listener);\n        return this;\n    }\n    off(event, listener) {\n        const t = thread();\n        if (!t) {\n            return;\n        }\n        t.off(event, listener);\n        return this;\n    }\n    navigate(navigateOptions) {\n        const t = thread();\n        if (!t) {\n            return;\n        }\n        return t.navigate(navigateOptions);\n    }\n    openSignRequest(openSignRequestOptions) {\n        const t = thread();\n        if (t) {\n            if (openSignRequestOptions === null || openSignRequestOptions === void 0 ? void 0 : openSignRequestOptions.uuid) {\n                return t.openSignRequest(openSignRequestOptions);\n            }\n        }\n        return;\n    }\n    selectDestination(selectDestinationOptions) {\n        const t = thread();\n        if (!t) {\n            return;\n        }\n        return t.selectDestination(selectDestinationOptions);\n    }\n    openBrowser(openBrowserOptions) {\n        const t = thread();\n        if (!t) {\n            return;\n        }\n        return t.openBrowser(openBrowserOptions);\n    }\n    share(shareOptions) {\n        const t = thread();\n        if (!t) {\n            return;\n        }\n        return t.share(shareOptions);\n    }\n    scanQr() {\n        const t = thread();\n        if (!t) {\n            return;\n        }\n        return t.scanQr();\n    }\n    tx(txOptions) {\n        const t = thread();\n        if (!t) {\n            return;\n        }\n        return t.tx(txOptions);\n    }\n    close(closeOptions) {\n        const t = thread();\n        if (!t) {\n            return;\n        }\n        return t.close(closeOptions);\n    }\n    ready() {\n        const t = thread();\n        if (!t) {\n            return;\n        }\n        return t.ready();\n    }\n    customCommand(customCommand, customCommandOptions) {\n        const t = thread();\n        if (!t) {\n            return;\n        }\n        return t.customCommand(customCommand, customCommandOptions);\n    }\n}\nexports.xApp = xApp;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMveHVtbS14YXBwLXNkay9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG9DQUFvQztBQUNuRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsK0RBQStELGlCQUFpQjtBQUM1RztBQUNBLG9DQUFvQyxNQUFNLCtCQUErQixZQUFZO0FBQ3JGLG1DQUFtQyxNQUFNLG1DQUFtQyxZQUFZO0FBQ3hGLGdDQUFnQztBQUNoQztBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELFlBQVk7QUFDWixpQkFBaUIsbUJBQU8sQ0FBQyxzQkFBUTtBQUNqQyxnQkFBZ0IsbUJBQU8sQ0FBQyxpRUFBUztBQUNqQyxhQUFhLG1CQUFPLENBQUMsaUVBQVM7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRDtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBLHlEQUF5RCxTQUFTLGdCQUFnQjtBQUNsRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEdBQThHO0FBQzlHLDhDQUE4QyxPQUFPLHNCQUFzQixRQUFRO0FBQ25GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBELEVBQUUsVUFBVSxFQUFFLFdBQVcsRUFBRSxnQkFBZ0IsRUFBRSxVQUFVLEdBQUc7QUFDcEg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsR0FBRyxRQUFRLEdBQUcsUUFBUSxHQUFHLGlCQUFpQixFQUFFLFVBQVUsRUFBRSxXQUFXLEVBQUUsZ0JBQWdCLEVBQUUsVUFBVSxHQUFHO0FBQ2xKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVkiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9taWNyb2xlbmRlci8uL25vZGVfbW9kdWxlcy94dW1tLXhhcHAtc2RrL2Rpc3QvaW5kZXguanM/NWI2MSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcbiAgICBpZiAoIWRlc2MgfHwgKFwiZ2V0XCIgaW4gZGVzYyA/ICFtLl9fZXNNb2R1bGUgOiBkZXNjLndyaXRhYmxlIHx8IGRlc2MuY29uZmlndXJhYmxlKSkge1xuICAgICAgZGVzYyA9IHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCBkZXNjKTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19leHBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2V4cG9ydFN0YXIpIHx8IGZ1bmN0aW9uKG0sIGV4cG9ydHMpIHtcbiAgICBmb3IgKHZhciBwIGluIG0pIGlmIChwICE9PSBcImRlZmF1bHRcIiAmJiAhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGV4cG9ydHMsIHApKSBfX2NyZWF0ZUJpbmRpbmcoZXhwb3J0cywgbSwgcCk7XG59O1xudmFyIF9fYXdhaXRlciA9ICh0aGlzICYmIHRoaXMuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICB9KTtcbn07XG52YXIgX2E7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnhBcHAgPSB2b2lkIDA7XG5jb25zdCBldmVudHNfMSA9IHJlcXVpcmUoXCJldmVudHNcIik7XG5jb25zdCB0eXBlc18xID0gcmVxdWlyZShcIi4vdHlwZXNcIik7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vdHlwZXNcIiksIGV4cG9ydHMpO1xuLy8gbG9jYWxTdG9yYWdlLmRlYnVnID0gXCJ4YXBwKlwiO1xuY29uc3QgZG9jTWluQWxpdmVTZWMgPSAwLjI1O1xuY29uc3QgYXR0ZW1wdE1zID0gMjUwO1xuY29uc3QgYXR0ZW1wdER1cmF0aW9uID0gMjAwMDtcbmNvbnN0IGFwcFN0YXJ0ID0gTnVtYmVyKG5ldyBEYXRlKCkpO1xubGV0IGRvY3VtZW50SXNSZWFkeTtcbmNvbnN0IGRvY3VtZW50UmVhZHlQcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICBkb2N1bWVudElzUmVhZHkgPSAodmFsdWUpID0+IHtcbiAgICAgICAgY29uc29sZS5sb2coXCJEb2MgUmVhZHkuLi5cIik7XG4gICAgICAgIGNvbnN0IHRpbWVTaW5jZURvY0xvYWQgPSAoTnVtYmVyKG5ldyBEYXRlKCkpIC0gYXBwU3RhcnQpIC8gMTAwMDtcbiAgICAgICAgaWYgKHRpbWVTaW5jZURvY0xvYWQgPCBkb2NNaW5BbGl2ZVNlYyAvKiBTZWNvbmRzICovKSB7XG4gICAgICAgICAgICAvLyBTdGFsbFxuICAgICAgICAgICAgY29uc29sZS5sb2coXCJEb2Mgbm90IGFsaXZlID49IFwiICtcbiAgICAgICAgICAgICAgICBkb2NNaW5BbGl2ZVNlYyArXG4gICAgICAgICAgICAgICAgXCIgc2VjLCBzdGFsbGluZyBmb3IgXCIgK1xuICAgICAgICAgICAgICAgIChkb2NNaW5BbGl2ZVNlYyAtIHRpbWVTaW5jZURvY0xvYWQpKTtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJlc29sdmUodmFsdWUpO1xuICAgICAgICAgICAgfSwgKGRvY01pbkFsaXZlU2VjIC0gdGltZVNpbmNlRG9jTG9hZCkgKiAxMDAwKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIEdvIGFoZWFkXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcIkRvYyBhbGl2ZSBcIiArIGRvY01pbkFsaXZlU2VjICsgXCIrIHNlYywgZ28gYWhlYWRcIik7XG4gICAgICAgICAgICByZXNvbHZlKHZhbHVlKTtcbiAgICAgICAgfVxuICAgIH07XG59KTtcbmRvY3VtZW50UmVhZHlQcm9taXNlXG4gICAgLnRoZW4oKCkgPT4ge1xuICAgIGNvbnNvbGUubG9nKFwiZG9jdW1lbnRSZWFkeVByb21pc2UgcmVzb2x2ZWRcIik7XG59KVxuICAgIC5jYXRjaCgoZSkgPT4ge1xuICAgIGNvbnNvbGUubG9nKGUpO1xufSk7XG5pZiAodHlwZW9mIGRvY3VtZW50ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcInJlYWR5c3RhdGVjaGFuZ2VcIiwgKGV2ZW50KSA9PiB7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiKHJlYWR5c3RhdGVjaGFuZ2U6IFsgXCIgKyBkb2N1bWVudC5yZWFkeVN0YXRlICsgXCIgXSlcIik7XG4gICAgICAgIGlmIChkb2N1bWVudC5yZWFkeVN0YXRlID09PSBcImNvbXBsZXRlXCIpIHtcbiAgICAgICAgICAgIGRvY3VtZW50SXNSZWFkeSgpO1xuICAgICAgICB9XG4gICAgfSk7XG59XG5pZiAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgIGNvbnNvbGUubG9nKFwiTG9hZGluZyB4QXBwIFNES1wiKTtcbn1cbmxldCBfd2luZG93ID0gKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSk7XG5sZXQgaXNTYW5kYm94ID0gZmFsc2U7XG5pZiAoX3dpbmRvdyA9PT0gbnVsbCB8fCBfd2luZG93ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfd2luZG93LnBhcmVudCkge1xuICAgIC8vIFhBUFAgUFJPWFlcbiAgICAoX2EgPSBfd2luZG93LnBhcmVudCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnBvc3RNZXNzYWdlKFwiWEFQUF9QUk9YWV9JTklUXCIsIFwiKlwiKTtcbn1cbmNvbnN0IHhBcHBBY3Rpb25BdHRlbXB0ID0gKGNvbW1hbmQsIG9wdGlvbnMsIGF0dGVtcHQgPSAwKSA9PiBfX2F3YWl0ZXIodm9pZCAwLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICB2YXIgX2IsIF9jO1xuICAgIHlpZWxkIGRvY3VtZW50UmVhZHlQcm9taXNlO1xuICAgIGlmICh0eXBlb2YgKF93aW5kb3cgPT09IG51bGwgfHwgX3dpbmRvdyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3dpbmRvdy5SZWFjdE5hdGl2ZVdlYlZpZXcpICE9PSBcInVuZGVmaW5lZFwiIHx8IGlzU2FuZGJveCkge1xuICAgICAgICBjb25zdCB0aW1lU2luY2VEb2NMb2FkID0gKE51bWJlcihuZXcgRGF0ZSgpKSAtIGFwcFN0YXJ0KSAvIDEwMDA7XG4gICAgICAgIGlmIChbXCJjbG9zZVwiXS5pbmRleE9mKGNvbW1hbmQpID4gLTEpIHtcbiAgICAgICAgICAgIC8vIENsb3NlIGNvbW1hbmQgYXdhaXRzIGFwcCBuYXYgc3RhdGUsIG1pbiBzZWMuIGFsaXZlIDRcbiAgICAgICAgICAgIGNvbnN0IG1pbkFsaXZlVGltZVNlYyA9IDQ7XG4gICAgICAgICAgICBpZiAodGltZVNpbmNlRG9jTG9hZCA8IG1pbkFsaXZlVGltZVNlYykge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwieEFwcCBjbG9zZSwgZG9jIGFsaXZlIDwgbWluQWxpdmVUaW1lU2VjLCBzdGFsbDogXCIgK1xuICAgICAgICAgICAgICAgICAgICAobWluQWxpdmVUaW1lU2VjIC0gdGltZVNpbmNlRG9jTG9hZCkpO1xuICAgICAgICAgICAgICAgIHlpZWxkIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSh0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgfSwgKG1pbkFsaXZlVGltZVNlYyAtIHRpbWVTaW5jZURvY0xvYWQpICogMTAwMCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbXNnVG9Qb3N0ID0gSlNPTi5zdHJpbmdpZnkoT2JqZWN0LmFzc2lnbih7IGNvbW1hbmQgfSwgKG9wdGlvbnMgfHwge30pKSk7XG4gICAgICAgIGlmIChpc1NhbmRib3gpIHtcbiAgICAgICAgICAgIChfYiA9IF93aW5kb3cucGFyZW50KSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IucG9zdE1lc3NhZ2UobXNnVG9Qb3N0LCBcIipcIik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAoX2MgPSBfd2luZG93LlJlYWN0TmF0aXZlV2ViVmlldykgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLnBvc3RNZXNzYWdlKG1zZ1RvUG9zdCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc29sZS5sb2coXCJ4QXBwQWN0aW9uQXR0ZW1wdCBTdWNjZXNzXCIsIGNvbW1hbmQsIG9wdGlvbnMpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGlmIChhdHRlbXB0ICogYXR0ZW1wdE1zIDwgYXR0ZW1wdER1cmF0aW9uKSB7XG4gICAgICAgICAgICAvLyBBbm90aGVyIGF0dGVtcHRcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwieEFwcEFjdGlvbkF0dGVtcHQgQXR0ZW1wdCBcIiArIGF0dGVtcHQgKyBcIiDCuyBSZXRyeVwiLCBjb21tYW5kLCBvcHRpb25zKTtcbiAgICAgICAgICAgIHlpZWxkIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICAgICAgICAgICAgc2V0VGltZW91dChyZXNvbHZlLCBhdHRlbXB0TXMpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4geEFwcEFjdGlvbkF0dGVtcHQoY29tbWFuZCwgb3B0aW9ucywgYXR0ZW1wdCArIDEpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gTm9wZVxuICAgICAgICAgICAgY29uc29sZS5sb2coXCJ4QXBwQWN0aW9uQXR0ZW1wdCBGYWlsZWQgYWZ0ZXIgYXR0ZW1wdCBcIiArIGF0dGVtcHQsIGNvbW1hbmQsIG9wdGlvbnMpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBFcnJvcihcInhBcHAuXCIgK1xuICAgICAgICAgICAgICAgIGNvbW1hbmQucmVwbGFjZSgvXnhBcHAvLCBcIlwiKSArXG4gICAgICAgICAgICAgICAgXCI6IGNvdWxkIG5vdCBjb250YWN0IFh1bW0gQXBwIEhvc3RcIik7XG4gICAgICAgIH1cbiAgICB9XG59KTtcbmNsYXNzIHhBcHBUaHJlYWQgZXh0ZW5kcyBldmVudHNfMS5FdmVudEVtaXR0ZXIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICBpZiAoZG9jdW1lbnQucmVhZHlTdGF0ZSA9PT0gXCJjb21wbGV0ZVwiKSB7XG4gICAgICAgICAgICBkb2N1bWVudElzUmVhZHkoKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBldmVudEhhbmRsZXIgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHJFdmVudCA9IGV2ZW50O1xuICAgICAgICAgICAgaWYgKHR5cGVvZiAockV2ZW50ID09PSBudWxsIHx8IHJFdmVudCA9PT0gdm9pZCAwID8gdm9pZCAwIDogckV2ZW50LmRhdGEpID09PSBcInN0cmluZ1wiICYmXG4gICAgICAgICAgICAgICAgckV2ZW50LmRhdGEgPT09IFwiWEFQUF9QUk9YWV9JTklUX0FDS1wiKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJ4QXBwIFByb3h5IEFDSyByZWNlaXZlZCwgc3dpdGNoaW5nIHRvIFBST1hZIChTQU5EQk9YKSBtb2RlXCIpO1xuICAgICAgICAgICAgICAgIGlzU2FuZGJveCA9IHRydWU7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCBfZXZlbnQgPSBKU09OLnBhcnNlKChyRXZlbnQgPT09IG51bGwgfHwgckV2ZW50ID09PSB2b2lkIDAgPyB2b2lkIDAgOiByRXZlbnQuZGF0YSkgfHwgXCJ7fVwiKTtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIl9ldmVudCAodHlwZW9mLCB7X2V2ZW50fSkgXCIsIHR5cGVvZiBfZXZlbnQsIHsgX2V2ZW50IH0pO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgX2V2ZW50ID09PSBcIm9iamVjdFwiICYmIF9ldmVudCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIF9ldmVudC5tZXRob2QgPT09IFwic3RyaW5nXCIgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIF9ldmVudC5tZXRob2QgaW4gdHlwZXNfMS54QXBwRXZlbnRzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcInhBcHAgRXZlbnQgcmVjZWl2ZWRcIiwgX2V2ZW50Lm1ldGhvZCwgX2V2ZW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG1ldGhvZCA9IF9ldmVudC5tZXRob2Q7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgX2V2ZW50Lm1ldGhvZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaCAobWV0aG9kKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBTdHJpbmcodHlwZXNfMS54QXBwRXZlbnRzLnBheWxvYWRSZXNvbHZlZCk6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdChcInBheWxvYWRcIiwgX2V2ZW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBTdHJpbmcodHlwZXNfMS54QXBwRXZlbnRzLnNjYW5Rcik6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdChcInFyXCIsIF9ldmVudCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgU3RyaW5nKHR5cGVzXzEueEFwcEV2ZW50cy5uZXR3b3JrU3dpdGNoKTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KFwibmV0d29ya3N3aXRjaFwiLCBfZXZlbnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFN0cmluZyh0eXBlc18xLnhBcHBFdmVudHMuc2VsZWN0RGVzdGluYXRpb24pOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoXCJkZXN0aW5hdGlvblwiLCBfZXZlbnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwieEFwcCBFdmVudCByZWNlaXZlZCwgbm90IGluIHhBcHBFdmVudHM6XCIsIF9ldmVudC5tZXRob2QpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBlbWVzc2FnZSA9IChlID09PSBudWxsIHx8IGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGUubWVzc2FnZSkgfHwgXCJcIjtcbiAgICAgICAgICAgICAgICBpZiAoIWVtZXNzYWdlLm1hdGNoKC9YQVBQX1BST1hZX0lOSVQvKSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcInhBcHAgRXZlbnQgcmVjZWl2ZWQsIGNhbm5vdCBwYXJzZSBhcyBKU09OXCIsIGVtZXNzYWdlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGlmICh0eXBlb2Ygd2luZG93LmFkZEV2ZW50TGlzdGVuZXIgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsIGV2ZW50SGFuZGxlcik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsIGV2ZW50SGFuZGxlcik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0RW52aXJvbm1lbnQoKSB7XG4gICAgICAgIGNvbnN0IHQgPSB0aHJlYWQoKTtcbiAgICAgICAgaWYgKCF0KSB7XG4gICAgICAgICAgICByZXR1cm4geyB2ZXJzaW9uOiBcIlwiLCBvdHQ6IFwiXCIgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdC5nZXRFbnZpcm9ubWVudCgpO1xuICAgIH1cbiAgICBuYXZpZ2F0ZShuYXZpZ2F0ZU9wdGlvbnMpIHtcbiAgICAgICAgaWYgKHR5cGVvZiAobmF2aWdhdGVPcHRpb25zID09PSBudWxsIHx8IG5hdmlnYXRlT3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogbmF2aWdhdGVPcHRpb25zLnhBcHApICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKFwieEFwcC5uYXZpZ2F0ZTogSW52YWxpZCBhcmd1bWVudDogYHhBcHBgXCIpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geEFwcEFjdGlvbkF0dGVtcHQoXCJ4QXBwTmF2aWdhdGVcIiwgbmF2aWdhdGVPcHRpb25zKTtcbiAgICB9XG4gICAgb3BlblNpZ25SZXF1ZXN0KG9wZW5TaWduUmVxdWVzdE9wdGlvbnMpIHtcbiAgICAgICAgaWYgKHR5cGVvZiAob3BlblNpZ25SZXF1ZXN0T3B0aW9ucyA9PT0gbnVsbCB8fCBvcGVuU2lnblJlcXVlc3RPcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcGVuU2lnblJlcXVlc3RPcHRpb25zLnV1aWQpICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKFwieEFwcC5vcGVuU2lnblJlcXVlc3Q6IEludmFsaWQgYXJndW1lbnQ6IGB1dWlkYFwiKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFvcGVuU2lnblJlcXVlc3RPcHRpb25zLnV1aWQubWF0Y2goL15bMC05QS1GXXs4fS1bMC05QS1GXXs0fS00WzAtOUEtRl17M30tWzg5QUJdWzAtOUEtRl17M30tWzAtOUEtRl17MTJ9JC9pKSkge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcihcInhBcHAub3BlblNpZ25SZXF1ZXN0OiBJbnZhbGlkIHBheWxvYWQgVVVJRFwiKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHhBcHBBY3Rpb25BdHRlbXB0KFwib3BlblNpZ25SZXF1ZXN0XCIsIG9wZW5TaWduUmVxdWVzdE9wdGlvbnMpO1xuICAgIH1cbiAgICBzZWxlY3REZXN0aW5hdGlvbihzZWxlY3REZXN0aW5hdGlvbk9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHhBcHBBY3Rpb25BdHRlbXB0KFwic2VsZWN0RGVzdGluYXRpb25cIiwgc2VsZWN0RGVzdGluYXRpb25PcHRpb25zKTtcbiAgICB9XG4gICAgb3BlbkJyb3dzZXIob3BlbkJyb3dzZXJPcHRpb25zKSB7XG4gICAgICAgIGlmICh0eXBlb2YgKG9wZW5Ccm93c2VyT3B0aW9ucyA9PT0gbnVsbCB8fCBvcGVuQnJvd3Nlck9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wZW5Ccm93c2VyT3B0aW9ucy51cmwpICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKFwieEFwcC5vcGVuQnJvd3NlcjogSW52YWxpZCBhcmd1bWVudDogYHVybGBcIikpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB4QXBwQWN0aW9uQXR0ZW1wdChcIm9wZW5Ccm93c2VyXCIsIG9wZW5Ccm93c2VyT3B0aW9ucyk7XG4gICAgfVxuICAgIHNoYXJlKHNoYXJlT3B0aW9ucykge1xuICAgICAgICBpZiAodHlwZW9mIChzaGFyZU9wdGlvbnMgPT09IG51bGwgfHwgc2hhcmVPcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzaGFyZU9wdGlvbnMudGV4dCkgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoXCJ4QXBwLnNoYXJlOiBJbnZhbGlkIGFyZ3VtZW50OiBgdGV4dGBcIikpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB4QXBwQWN0aW9uQXR0ZW1wdChcInNoYXJlXCIsIHNoYXJlT3B0aW9ucyk7XG4gICAgfVxuICAgIHNjYW5RcigpIHtcbiAgICAgICAgcmV0dXJuIHhBcHBBY3Rpb25BdHRlbXB0KFwic2NhblFyXCIpO1xuICAgIH1cbiAgICB0eCh0eE9wdGlvbnMpIHtcbiAgICAgICAgaWYgKHR5cGVvZiAodHhPcHRpb25zID09PSBudWxsIHx8IHR4T3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogdHhPcHRpb25zLnR4KSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcihcInhBcHAudHg6IEludmFsaWQgYXJndW1lbnQ6IGB0eGBcIikpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgKHR4T3B0aW9ucyA9PT0gbnVsbCB8fCB0eE9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHR4T3B0aW9ucy5hY2NvdW50KSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcihcInhBcHAudHg6IEludmFsaWQgYXJndW1lbnQ6IGBhY2NvdW50YFwiKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHhBcHBBY3Rpb25BdHRlbXB0KFwidHhEZXRhaWxzXCIsIHR4T3B0aW9ucyk7XG4gICAgfVxuICAgIGNsb3NlKGNsb3NlT3B0aW9ucykge1xuICAgICAgICByZXR1cm4geEFwcEFjdGlvbkF0dGVtcHQoXCJjbG9zZVwiLCBjbG9zZU9wdGlvbnMpO1xuICAgIH1cbiAgICByZWFkeSgpIHtcbiAgICAgICAgcmV0dXJuIHhBcHBBY3Rpb25BdHRlbXB0KFwicmVhZHlcIik7XG4gICAgfVxuICAgIGN1c3RvbUNvbW1hbmQoY3VzdG9tQ29tbWFuZCwgY3VzdG9tQ29tbWFuZE9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHhBcHBBY3Rpb25BdHRlbXB0KGN1c3RvbUNvbW1hbmQsIGN1c3RvbUNvbW1hbmRPcHRpb25zKTtcbiAgICB9XG59XG5jb25zdCB0aHJlYWQgPSAoX3hBcHApID0+IHtcbiAgICBsZXQgYXR0YWNoZWQgPSBmYWxzZTtcbiAgICBpZiAoX3hBcHApIHtcbiAgICAgICAgaWYgKHR5cGVvZiBfd2luZG93ID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIF93aW5kb3cuX3hBcHBTZGsgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgICAgICBfd2luZG93Ll94QXBwU2RrID0gX3hBcHA7XG4gICAgICAgICAgICAgICAgYXR0YWNoZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGluc3RhbmNlID0gX3dpbmRvdyA9PT0gbnVsbCB8fCBfd2luZG93ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfd2luZG93Ll94QXBwU2RrO1xuICAgIGlmIChpbnN0YW5jZSAmJiBhdHRhY2hlZCkge1xuICAgICAgICBjb25zb2xlLmxvZyhcInhBcHBTZGsgYXR0YWNoZWQgdG8gd2luZG93XCIpO1xuICAgIH1cbiAgICByZXR1cm4gaW5zdGFuY2U7XG59O1xuY2xhc3MgeEFwcCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMueHVtbUVudmlyb25tZW50ID0ge1xuICAgICAgICAgICAgdmVyc2lvbjogXCJcIixcbiAgICAgICAgICAgIG90dDogXCJcIixcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09IFwidW5kZWZpbmVkXCIgfHwgdHlwZW9mIGRvY3VtZW50ID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBuYXZpZ2F0b3IgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgKG5hdmlnYXRvciA9PT0gbnVsbCB8fCBuYXZpZ2F0b3IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG5hdmlnYXRvci51c2VyQWdlbnQpID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdWFNYXRjaCA9IG5hdmlnYXRvci51c2VyQWdlbnRcbiAgICAgICAgICAgICAgICAgICAgLnRyaW0oKVxuICAgICAgICAgICAgICAgICAgICAubWF0Y2goL3h1bW1cXC94YXBwOihbMC05XXsxLH1cXC5bMC05XXsxLH1cXC5bMC05XXsxLH0pLipvdHQ6KFswLTlhLWZdezh9LVswLTlhLWZdezR9LTRbMC05YS1mXXszfS1bODlhYl1bMC05YS1mXXszfS1bMC05YS1mXXsxMn0pLyk7XG4gICAgICAgICAgICAgICAgaWYgKHVhTWF0Y2gpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy54dW1tRW52aXJvbm1lbnQudmVyc2lvbiA9IHVhTWF0Y2hbMV07XG4gICAgICAgICAgICAgICAgICAgIHRoaXMueHVtbUVudmlyb25tZW50Lm90dCA9IHVhTWF0Y2hbMl07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnh1bW1FbnZpcm9ubWVudC52ZXJzaW9uID09PSBcIlwiKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcIldhcm5pbmc6IFh1bW0gVmVyc2lvbiBjb3VsZCBub3QgYmUgcmV0cmlldmVkIGZyb20gVXNlciBBZ2VudCwgcG9zc2libHkgbm90IGxvYWRlZCBpbiB4QXBwIGNvbnRleHQ/XCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhyZWFkKCkpIHtcbiAgICAgICAgICAgIHRocmVhZChuZXcgeEFwcFRocmVhZCgpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXRFbnZpcm9ubWVudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMueHVtbUVudmlyb25tZW50O1xuICAgIH1cbiAgICBvbihldmVudCwgbGlzdGVuZXIpIHtcbiAgICAgICAgY29uc3QgdCA9IHRocmVhZCgpO1xuICAgICAgICBpZiAoIXQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0Lm9uKGV2ZW50LCBsaXN0ZW5lcik7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBvZmYoZXZlbnQsIGxpc3RlbmVyKSB7XG4gICAgICAgIGNvbnN0IHQgPSB0aHJlYWQoKTtcbiAgICAgICAgaWYgKCF0KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdC5vZmYoZXZlbnQsIGxpc3RlbmVyKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIG5hdmlnYXRlKG5hdmlnYXRlT3B0aW9ucykge1xuICAgICAgICBjb25zdCB0ID0gdGhyZWFkKCk7XG4gICAgICAgIGlmICghdCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0Lm5hdmlnYXRlKG5hdmlnYXRlT3B0aW9ucyk7XG4gICAgfVxuICAgIG9wZW5TaWduUmVxdWVzdChvcGVuU2lnblJlcXVlc3RPcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IHQgPSB0aHJlYWQoKTtcbiAgICAgICAgaWYgKHQpIHtcbiAgICAgICAgICAgIGlmIChvcGVuU2lnblJlcXVlc3RPcHRpb25zID09PSBudWxsIHx8IG9wZW5TaWduUmVxdWVzdE9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wZW5TaWduUmVxdWVzdE9wdGlvbnMudXVpZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0Lm9wZW5TaWduUmVxdWVzdChvcGVuU2lnblJlcXVlc3RPcHRpb25zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHNlbGVjdERlc3RpbmF0aW9uKHNlbGVjdERlc3RpbmF0aW9uT3B0aW9ucykge1xuICAgICAgICBjb25zdCB0ID0gdGhyZWFkKCk7XG4gICAgICAgIGlmICghdCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0LnNlbGVjdERlc3RpbmF0aW9uKHNlbGVjdERlc3RpbmF0aW9uT3B0aW9ucyk7XG4gICAgfVxuICAgIG9wZW5Ccm93c2VyKG9wZW5Ccm93c2VyT3B0aW9ucykge1xuICAgICAgICBjb25zdCB0ID0gdGhyZWFkKCk7XG4gICAgICAgIGlmICghdCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0Lm9wZW5Ccm93c2VyKG9wZW5Ccm93c2VyT3B0aW9ucyk7XG4gICAgfVxuICAgIHNoYXJlKHNoYXJlT3B0aW9ucykge1xuICAgICAgICBjb25zdCB0ID0gdGhyZWFkKCk7XG4gICAgICAgIGlmICghdCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0LnNoYXJlKHNoYXJlT3B0aW9ucyk7XG4gICAgfVxuICAgIHNjYW5RcigpIHtcbiAgICAgICAgY29uc3QgdCA9IHRocmVhZCgpO1xuICAgICAgICBpZiAoIXQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdC5zY2FuUXIoKTtcbiAgICB9XG4gICAgdHgodHhPcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IHQgPSB0aHJlYWQoKTtcbiAgICAgICAgaWYgKCF0KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHQudHgodHhPcHRpb25zKTtcbiAgICB9XG4gICAgY2xvc2UoY2xvc2VPcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IHQgPSB0aHJlYWQoKTtcbiAgICAgICAgaWYgKCF0KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHQuY2xvc2UoY2xvc2VPcHRpb25zKTtcbiAgICB9XG4gICAgcmVhZHkoKSB7XG4gICAgICAgIGNvbnN0IHQgPSB0aHJlYWQoKTtcbiAgICAgICAgaWYgKCF0KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHQucmVhZHkoKTtcbiAgICB9XG4gICAgY3VzdG9tQ29tbWFuZChjdXN0b21Db21tYW5kLCBjdXN0b21Db21tYW5kT3B0aW9ucykge1xuICAgICAgICBjb25zdCB0ID0gdGhyZWFkKCk7XG4gICAgICAgIGlmICghdCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0LmN1c3RvbUNvbW1hbmQoY3VzdG9tQ29tbWFuZCwgY3VzdG9tQ29tbWFuZE9wdGlvbnMpO1xuICAgIH1cbn1cbmV4cG9ydHMueEFwcCA9IHhBcHA7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/xumm-xapp-sdk/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/xumm-xapp-sdk/dist/types.js":
/*!**************************************************!*\
  !*** ./node_modules/xumm-xapp-sdk/dist/types.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.xAppEvents = void 0;\nvar xAppEvents;\n(function (xAppEvents) {\n    xAppEvents[\"ready\"] = \"ready\";\n    xAppEvents[\"scanQr\"] = \"scanQr\";\n    xAppEvents[\"payloadResolved\"] = \"payloadResolved\";\n    xAppEvents[\"selectDestination\"] = \"selectDestination\";\n    xAppEvents[\"networkSwitch\"] = \"networkSwitch\";\n})(xAppEvents = exports.xAppEvents || (exports.xAppEvents = {}));\n// export interface xAppActionScanQr {\n//   // command: scanQr\n// }\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMveHVtbS14YXBwLXNkay9kaXN0L3R5cGVzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsc0NBQXNDLGtCQUFrQixLQUFLO0FBQzlEO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL21pY3JvbGVuZGVyLy4vbm9kZV9tb2R1bGVzL3h1bW0teGFwcC1zZGsvZGlzdC90eXBlcy5qcz9jZGQzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy54QXBwRXZlbnRzID0gdm9pZCAwO1xudmFyIHhBcHBFdmVudHM7XG4oZnVuY3Rpb24gKHhBcHBFdmVudHMpIHtcbiAgICB4QXBwRXZlbnRzW1wicmVhZHlcIl0gPSBcInJlYWR5XCI7XG4gICAgeEFwcEV2ZW50c1tcInNjYW5RclwiXSA9IFwic2NhblFyXCI7XG4gICAgeEFwcEV2ZW50c1tcInBheWxvYWRSZXNvbHZlZFwiXSA9IFwicGF5bG9hZFJlc29sdmVkXCI7XG4gICAgeEFwcEV2ZW50c1tcInNlbGVjdERlc3RpbmF0aW9uXCJdID0gXCJzZWxlY3REZXN0aW5hdGlvblwiO1xuICAgIHhBcHBFdmVudHNbXCJuZXR3b3JrU3dpdGNoXCJdID0gXCJuZXR3b3JrU3dpdGNoXCI7XG59KSh4QXBwRXZlbnRzID0gZXhwb3J0cy54QXBwRXZlbnRzIHx8IChleHBvcnRzLnhBcHBFdmVudHMgPSB7fSkpO1xuLy8gZXhwb3J0IGludGVyZmFjZSB4QXBwQWN0aW9uU2NhblFyIHtcbi8vICAgLy8gY29tbWFuZDogc2NhblFyXG4vLyB9XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/xumm-xapp-sdk/dist/types.js\n");

/***/ })

};
;